{
  "metadata": {
    "version": "1.0",
    "lastUpdated": "2024-10-30",
    "totalProblems": 62,
    "format": {
      "input": "JSON object with problem-specific structure",
      "output": "Expected return value",
      "timeLimit": "Seconds allowed for execution",
      "memoryLimit": "16MB"
    }
  },
  "testCases": {
    "1": {
      "title": "Two Sum",
      "description": "Given an array of integers nums and an integer target, return the indices i and j such that nums[i] + nums[j] == target and i != j.\n\nYou may assume that every input has exactly one pair of indices i and j that satisfy the condition.\n\nReturn the answer with the smaller index first.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [2, 7, 11, 15],
            "target": 9
          },
          "output": [0, 1],
          "explanation": "nums[0] + nums[1] = 2 + 7 = 9"
        },
        {
          "id": 2,
          "input": {
            "nums": [3, 2, 4],
            "target": 6
          },
          "output": [1, 2],
          "explanation": "nums[1] + nums[2] = 2 + 4 = 6"
        },
        {
          "id": 3,
          "input": {
            "nums": [3, 3],
            "target": 6
          },
          "output": [0, 1],
          "explanation": "nums[0] + nums[1] = 3 + 3 = 6"
        },
        {
          "id": 4,
          "input": {
            "nums": [-1, -2, -3, -4, -5],
            "target": -8
          },
          "output": [2, 4],
          "explanation": "nums[2] + nums[4] = -3 + -5 = -8"
        },
        {
          "id": 5,
          "input": {
            "nums": [1000, 2000, 3000],
            "target": 5000
          },
          "output": [1, 2],
          "explanation": "nums[1] + nums[2] = 2000 + 3000 = 5000"
        }
      ],
      "constraints": {
        "2 <= nums.length <= 104": true,
        "-109 <= nums[i] <= 109": true,
        "-109 <= target <= 109": true
      }
    },
    "2": {
      "title": "Contains Duplicate",
      "description": "Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [1, 2, 3, 1]
          },
          "output": true,
          "explanation": "1 appears twice"
        },
        {
          "id": 2,
          "input": {
            "nums": [1, 2, 3, 4]
          },
          "output": false,
          "explanation": "All numbers are unique"
        },
        {
          "id": 3,
          "input": {
            "nums": [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
          },
          "output": true,
          "explanation": "Multiple numbers appear more than once"
        },
        {
          "id": 4,
          "input": {
            "nums": []
          },
          "output": false,
          "explanation": "Empty array has no duplicates"
        },
        {
          "id": 5,
          "input": {
            "nums": [-1, -1, 2, 2]
          },
          "output": true,
          "explanation": "Negative numbers can be duplicates"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 105": true,
        "-109 <= nums[i] <= 109": true
      }
    },
    "3": {
      "title": "Valid Anagram",
      "description": "Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false. An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "anagram",
            "t": "nagaram"
          },
          "output": true,
          "explanation": "Same letters used in different order"
        },
        {
          "id": 2,
          "input": {
            "s": "rat",
            "t": "car"
          },
          "output": false,
          "explanation": "Different letters used"
        },
        {
          "id": 3,
          "input": {
            "s": "",
            "t": ""
          },
          "output": true,
          "explanation": "Empty strings are anagrams"
        },
        {
          "id": 4,
          "input": {
            "s": "aacc",
            "t": "ccac"
          },
          "output": false,
          "explanation": "Different frequency of letters"
        },
        {
          "id": 5,
          "input": {
            "s": "hello",
            "t": "world"
          },
          "output": false,
          "explanation": "Different letters, same length"
        }
      ],
      "constraints": {
        "1 <= s.length, t.length <= 5 * 104": true,
        "s and t consist of lowercase English letters": true
      }
    },
    "4": {
      "title": "Group Anagrams",
      "description": "Given an array of strings strs, group all anagrams together into sublists.\n\nYou may return the output in any order.\n\nAn anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.",
      "cases": [
        {
          "id": 1,
          "input": {
            "strs": ["eat", "tea", "tan", "ate", "nat", "bat"]
          },
          "output": [["bat"], ["nat", "tan"], ["ate", "eat", "tea"]],
          "explanation": "Words with same letters grouped together"
        },
        {
          "id": 2,
          "input": {
            "strs": [""]
          },
          "output": [[""]],
          "explanation": "Single empty string"
        },
        {
          "id": 3,
          "input": {
            "strs": ["a"]
          },
          "output": [["a"]],
          "explanation": "Single character"
        },
        {
          "id": 4,
          "input": {
            "strs": ["", "b", ""]
          },
          "output": [["", ""], ["b"]],
          "explanation": "Multiple empty strings with other strings"
        },
        {
          "id": 5,
          "input": {
            "strs": ["abc", "def", "ghi"]
          },
          "output": [["abc"], ["def"], ["ghi"]],
          "explanation": "No anagrams present"
        }
      ],
      "constraints": {
        "1 <= strs.length <= 104": true,
        "0 <= strs[i].length <= 100": true,
        "strs[i] consists of lowercase English letters": true
      }
    },
    "5": {
      "title": "Top K Frequent Elements",
      "description": "Given an integer array nums and an integer k, return the k most frequent elements within the array.\n\nThe test cases are generated such that the answer is always unique.\n\nYou may return the output in any order.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [1, 1, 1, 2, 2, 3],
            "k": 2
          },
          "output": [1, 2],
          "explanation": "1 appears three times, 2 appears twice"
        },
        {
          "id": 2,
          "input": {
            "nums": [1],
            "k": 1
          },
          "output": [1],
          "explanation": "Single element array"
        },
        {
          "id": 3,
          "input": {
            "nums": [1, 2, 3, 1],
            "k": 1
          },
          "output": [1],
          "explanation": "1 is most frequent"
        },
        {
          "id": 4,
          "input": {
            "nums": [-1, -1, 2, 2, 3],
            "k": 2
          },
          "output": [-1, 2],
          "explanation": "Negative numbers included"
        },
        {
          "id": 5,
          "input": {
            "nums": [4, 4, 4, 4, 4],
            "k": 1
          },
          "output": [4],
          "explanation": "Single number repeated"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 105": true,
        "k is in range [1, number of unique elements]": true,
        "-104 <= nums[i] <= 104": true
      }
    },
    "6": {
      "title": "Product of Array Except Self",
      "description": "Given an integer array nums, return an array output where output[i] is the product of all the elements of nums except nums[i].\n\nEach product is guaranteed to fit in a 32-bit integer.\n\nFollow-up: Could you solve it in O(n) time without using the division operation?",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [1, 2, 3, 4]
          },
          "output": [24, 12, 8, 6],
          "explanation": "For index 0: 2*3*4=24, index 1: 1*3*4=12, etc."
        },
        {
          "id": 2,
          "input": {
            "nums": [-1, 1, 0, -3, 3]
          },
          "output": [0, 0, 9, 0, 0],
          "explanation": "Array with zero produces mostly zeros"
        },
        {
          "id": 3,
          "input": {
            "nums": [0, 0, 0, 0]
          },
          "output": [0, 0, 0, 0],
          "explanation": "All zeros case"
        },
        {
          "id": 4,
          "input": {
            "nums": [2, 2, 2, 2]
          },
          "output": [8, 8, 8, 8],
          "explanation": "All same numbers"
        },
        {
          "id": 5,
          "input": {
            "nums": [-1, -1, 2, -1]
          },
          "output": [-2, -2, 1, -2],
          "explanation": "Negative numbers included"
        }
      ],
      "constraints": {
        "2 <= nums.length <= 105": true,
        "-30 <= nums[i] <= 30": true,
        "The product of any prefix or suffix fits in a 32-bit integer": true
      }
    },
    "7": {
      "title": "Encode and Decode Strings",
      "description": "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nPlease implement encode and decode functions.",
      "cases": [
        {
          "id": 1,
          "input": {
            "strs": ["Hello", "World"]
          },
          "encoded": "5#Hello5#World",
          "decoded": ["Hello", "World"],
          "explanation": "Length prefix encoding"
        },
        {
          "id": 2,
          "input": {
            "strs": [""]
          },
          "encoded": "0#",
          "decoded": [""],
          "explanation": "Empty string encoding"
        },
        {
          "id": 3,
          "input": {
            "strs": ["Hello", "World", "#"]
          },
          "encoded": "5#Hello5#World1##",
          "decoded": ["Hello", "World", "#"],
          "explanation": "Handle delimiter in string"
        },
        {
          "id": 4,
          "input": {
            "strs": ["a", "b", "c"]
          },
          "encoded": "1#a1#b1#c",
          "decoded": ["a", "b", "c"],
          "explanation": "Single character strings"
        },
        {
          "id": 5,
          "input": {
            "strs": ["Hello#5#World"]
          },
          "encoded": "12#Hello#5#World",
          "decoded": ["Hello#5#World"],
          "explanation": "String containing encoding characters"
        }
      ],
      "constraints": {
        "0 <= strs.length <= 200": true,
        "0 <= strs[i].length <= 200": true,
        "strs[i] contains any possible characters out of 256 valid ASCII characters": true
      }
    },
    "8": {
      "title": "Longest Consecutive Sequence",
      "description": "Given an array of integers nums, return the length of the longest consecutive sequence of elements.\n\nA consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element.\n\nYou must write an algorithm that runs in O(n) time.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [100, 4, 200, 1, 3, 2]
          },
          "output": 4,
          "explanation": "The sequence 1,2,3,4 has length 4"
        },
        {
          "id": 2,
          "input": {
            "nums": [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
          },
          "output": 9,
          "explanation": "The sequence 0,1,2,3,4,5,6,7,8 has length 9"
        },
        {
          "id": 3,
          "input": {
            "nums": []
          },
          "output": 0,
          "explanation": "Empty array has no sequence"
        },
        {
          "id": 4,
          "input": {
            "nums": [1, 1, 1, 1]
          },
          "output": 1,
          "explanation": "Duplicates count as one number"
        },
        {
          "id": 5,
          "input": {
            "nums": [-5, -4, -3, -2, -1]
          },
          "output": 5,
          "explanation": "Negative consecutive sequence"
        }
      ],
      "constraints": {
        "0 <= nums.length <= 105": true,
        "-109 <= nums[i] <= 109": true
      }
    },
    "9": {
      "title": "Valid Palindrome",
      "description": "Given a string s, return true if it is a palindrome, otherwise return false.\n\nA palindrome is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "A man, a plan, a canal: Panama"
          },
          "output": true,
          "explanation": "amanaplanacanalpanama is palindrome"
        },
        {
          "id": 2,
          "input": {
            "s": "race a car"
          },
          "output": false,
          "explanation": "raceacar is not palindrome"
        },
        {
          "id": 3,
          "input": {
            "s": " "
          },
          "output": true,
          "explanation": "Empty string is palindrome"
        },
        {
          "id": 4,
          "input": {
            "s": "12321"
          },
          "output": true,
          "explanation": "Numeric palindrome"
        },
        {
          "id": 5,
          "input": {
            "s": "0P"
          },
          "output": false,
          "explanation": "Case insensitive comparison"
        }
      ],
      "constraints": {
        "1 <= s.length <= 2 * 105": true,
        "s consists only of printable ASCII characters": true
      }
    },
    "10": {
      "title": "3Sum",
      "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] where nums[i] + nums[j] + nums[k] == 0, and the indices i, j, and k are all distinct.\n\nThe output should not contain any duplicate triplets. You may return the output and the triplets in any order.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [-1, 0, 1, 2, -1, -4]
          },
          "output": [
            [-1, -1, 2],
            [-1, 0, 1]
          ],
          "explanation": "Two unique triplets sum to zero"
        },
        {
          "id": 2,
          "input": {
            "nums": []
          },
          "output": [],
          "explanation": "Empty array has no triplets"
        },
        {
          "id": 3,
          "input": {
            "nums": [0]
          },
          "output": [],
          "explanation": "Too few elements for triplet"
        },
        {
          "id": 4,
          "input": {
            "nums": [0, 0, 0]
          },
          "output": [[0, 0, 0]],
          "explanation": "All zeros is valid triplet"
        },
        {
          "id": 5,
          "input": {
            "nums": [-2, 0, 1, 1, 2]
          },
          "output": [
            [-2, 0, 2],
            [-2, 1, 1]
          ],
          "explanation": "Multiple solutions with same numbers"
        }
      ],
      "constraints": {
        "0 <= nums.length <= 3000": true,
        "-105 <= nums[i] <= 105": true
      }
    },
    "11": {
      "title": "Container With Most Water",
      "description": "You are given an integer array heights where heights[i] represents the height of the ith bar.\n\nYou may choose any two bars to form a container. Return the maximum amount of water a container can store.",
      "cases": [
        {
          "id": 1,
          "input": {
            "height": [1, 8, 6, 2, 5, 4, 8, 3, 7]
          },
          "output": 49,
          "explanation": "Container between indices 1 and 8 with height 7"
        },
        {
          "id": 2,
          "input": {
            "height": [1, 1]
          },
          "output": 1,
          "explanation": "Minimum case with two lines"
        },
        {
          "id": 3,
          "input": {
            "height": [4, 3, 2, 1, 4]
          },
          "output": 16,
          "explanation": "Same height at edges"
        },
        {
          "id": 4,
          "input": {
            "height": [1, 2, 4, 3]
          },
          "output": 4,
          "explanation": "Taller middle elements"
        },
        {
          "id": 5,
          "input": {
            "height": [2, 3, 4, 5, 18, 17, 6]
          },
          "output": 17,
          "explanation": "Peak heights in middle"
        }
      ],
      "constraints": {
        "n == height.length": true,
        "2 <= n <= 105": true,
        "0 <= height[i] <= 104": true
      }
    },
    "12": {
      "title": "Best Time to Buy and Sell Stock",
      "description": "You are given an integer array prices where prices[i] is the price of NeetCoin on the ith day.\n\nYou may choose a single day to buy one NeetCoin and choose a different day in the future to sell it.\n\nReturn the maximum profit you can achieve. You may choose to not make any transactions, in which case the profit would be 0.",
      "cases": [
        {
          "id": 1,
          "input": {
            "prices": [7, 1, 5, 3, 6, 4]
          },
          "output": 5,
          "explanation": "Buy at 1, sell at 6"
        },
        {
          "id": 2,
          "input": {
            "prices": [7, 6, 4, 3, 1]
          },
          "output": 0,
          "explanation": "No profit possible"
        },
        {
          "id": 3,
          "input": {
            "prices": [2, 4, 1]
          },
          "output": 2,
          "explanation": "Buy at 2, sell at 4"
        },
        {
          "id": 4,
          "input": {
            "prices": [1, 2]
          },
          "output": 1,
          "explanation": "Minimum case with profit"
        },
        {
          "id": 5,
          "input": {
            "prices": [3, 3, 3, 3]
          },
          "output": 0,
          "explanation": "No price change"
        }
      ],
      "constraints": {
        "1 <= prices.length <= 105": true,
        "0 <= prices[i] <= 104": true
      }
    },
    "13": {
      "title": "Longest Substring Without Repeating Characters",
      "description": "Given a string s, find the length of the longest substring without duplicate characters.\n\nA substring is a contiguous sequence of characters within a string.",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "abcabcbb"
          },
          "output": 3,
          "explanation": "The answer is abc, with length 3"
        },
        {
          "id": 2,
          "input": {
            "s": "bbbbb"
          },
          "output": 1,
          "explanation": "Single character is longest"
        },
        {
          "id": 3,
          "input": {
            "s": "pwwkew"
          },
          "output": 3,
          "explanation": "wke is the longest substring"
        },
        {
          "id": 4,
          "input": {
            "s": ""
          },
          "output": 0,
          "explanation": "Empty string case"
        },
        {
          "id": 5,
          "input": {
            "s": "aab"
          },
          "output": 2,
          "explanation": "ab is the longest substring"
        }
      ],
      "constraints": {
        "0 <= s.length <= 5 * 104": true,
        "s consists of English letters, digits, symbols and spaces": true
      }
    },
    "14": {
      "title": "Longest Repeating Character Replacement",
      "description": "You are given a string s consisting of only uppercase English characters and an integer k. You can choose up to k characters of the string and replace them with any other uppercase English character.\n\nAfter performing at most k replacements, return the length of the longest substring which contains only one distinct character.",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "ABAB",
            "k": 2
          },
          "output": 4,
          "explanation": "Replace both As with B to get all Bs"
        },
        {
          "id": 2,
          "input": {
            "s": "AABABBA",
            "k": 1
          },
          "output": 4,
          "explanation": "Replace one letter to get AABA"
        },
        {
          "id": 3,
          "input": {
            "s": "AAAA",
            "k": 2
          },
          "output": 4,
          "explanation": "Already all same character"
        },
        {
          "id": 4,
          "input": {
            "s": "ABCD",
            "k": 1
          },
          "output": 2,
          "explanation": "Can make any two adjacent same"
        },
        {
          "id": 5,
          "input": {
            "s": "AABABBBA",
            "k": 1
          },
          "output": 5,
          "explanation": "Replace one B to get AABA"
        }
      ],
      "constraints": {
        "1 <= s.length <= 105": true,
        "s consists of only uppercase English letters": true,
        "0 <= k <= s.length": true
      }
    },
    "15": {
      "title": "Minimum Window Substring",
      "description": "Given two strings s and t, return the shortest substring of s such that every character in t, including duplicates, is present in the substring.\n\nIf such a substring does not exist, return an empty string \"\".\n\nYou may assume that the correct output is always unique.",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "ADOBECODEBANC",
            "t": "ABC"
          },
          "output": "BANC",
          "explanation": "Smallest window containing A, B, and C"
        },
        {
          "id": 2,
          "input": {
            "s": "a",
            "t": "a"
          },
          "output": "a",
          "explanation": "Single character match"
        },
        {
          "id": 3,
          "input": {
            "s": "a",
            "t": "aa"
          },
          "output": "",
          "explanation": "No valid window exists"
        },
        {
          "id": 4,
          "input": {
            "s": "ABAACBAB",
            "t": "ABC"
          },
          "output": "ACB",
          "explanation": "Multiple possible windows, return shortest"
        },
        {
          "id": 5,
          "input": {
            "s": "ab",
            "t": "b"
          },
          "output": "b",
          "explanation": "Single character in longer string"
        }
      ],
      "constraints": {
        "1 <= s.length, t.length <= 105": true,
        "s and t consist of uppercase and lowercase English letters": true
      }
    },
    "16": {
      "title": "Valid Parentheses",
      "description": "You are given a string s consisting of the following characters: '(', ')', '{', '}', '[' and ']'.\n\nThe input string s is valid if and only if:\n\n1. Every open bracket is closed by the same type of close bracket.\n2. Open brackets are closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nReturn true if s is a valid string, and false otherwise.",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "()"
          },
          "output": true,
          "explanation": "Simple matching pair"
        },
        {
          "id": 2,
          "input": {
            "s": "()[]{}"
          },
          "output": true,
          "explanation": "Multiple different pairs"
        },
        {
          "id": 3,
          "input": {
            "s": "(]"
          },
          "output": false,
          "explanation": "Mismatched brackets"
        },
        {
          "id": 4,
          "input": {
            "s": "([)]"
          },
          "output": false,
          "explanation": "Incorrectly ordered pairs"
        },
        {
          "id": 5,
          "input": {
            "s": "{[]}"
          },
          "output": true,
          "explanation": "Nested brackets"
        }
      ],
      "constraints": {
        "1 <= s.length <= 104": true,
        "s consists of parentheses only '()[]{}": true
      }
    },
    "17": {
      "title": "Number of 1 Bits",
      "description": "You are given an unsigned integer n. Return the number of 1 bits in its binary representation.\n\nYou may assume n is a non-negative integer which fits within 32 bits.",
      "cases": [
        {
          "id": 1,
          "input": {
            "n": "00000000000000000000000000001011"
          },
          "output": 3,
          "explanation": "Three 1's in binary representation"
        },
        {
          "id": 2,
          "input": {
            "n": "00000000000000000000000010000000"
          },
          "output": 1,
          "explanation": "One 1 in binary representation"
        },
        {
          "id": 3,
          "input": {
            "n": "11111111111111111111111111111101"
          },
          "output": 31,
          "explanation": "Thirty one 1's in binary"
        },
        {
          "id": 4,
          "input": {
            "n": "00000000000000000000000000000000"
          },
          "output": 0,
          "explanation": "All zeros"
        },
        {
          "id": 5,
          "input": {
            "n": "11111111111111111111111111111111"
          },
          "output": 32,
          "explanation": "All ones"
        }
      ],
      "constraints": {
        "The input must be a binary string of length 32": true
      }
    },
    "18": {
      "title": "Counting Bits",
      "description": "Given an integer n, count the number of 1's in the binary representation of every number in the range [0, n].\n\nReturn an array output where output[i] is the number of 1's in the binary representation of i.",
      "cases": [
        {
          "id": 1,
          "input": {
            "n": 2
          },
          "output": [0, 1, 1],
          "explanation": "0 -> 0, 1 -> 1, 2 -> 10"
        },
        {
          "id": 2,
          "input": {
            "n": 5
          },
          "output": [0, 1, 1, 2, 1, 2],
          "explanation": "0->0, 1->1, 2->10, 3->11, 4->100, 5->101"
        },
        {
          "id": 3,
          "input": {
            "n": 0
          },
          "output": [0],
          "explanation": "Only zero case"
        },
        {
          "id": 4,
          "input": {
            "n": 1
          },
          "output": [0, 1],
          "explanation": "Binary 0 and 1"
        },
        {
          "id": 5,
          "input": {
            "n": 4
          },
          "output": [0, 1, 1, 2, 1],
          "explanation": "0->0, 1->1, 2->10, 3->11, 4->100"
        }
      ],
      "constraints": {
        "0 <= n <= 105": true
      }
    },
    "19": {
      "title": "Missing Number",
      "description": "Given an array nums containing n integers in the range [0, n] without any duplicates, return the single number in the range that is missing from nums.\n\nFollow-up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [3, 0, 1]
          },
          "output": 2,
          "explanation": "2 is missing from [0,1,2,3]"
        },
        {
          "id": 2,
          "input": {
            "nums": [0, 1]
          },
          "output": 2,
          "explanation": "2 is missing from [0,1,2]"
        },
        {
          "id": 3,
          "input": {
            "nums": [9, 6, 4, 2, 3, 5, 7, 0, 1]
          },
          "output": 8,
          "explanation": "8 is missing from [0-9]"
        },
        {
          "id": 4,
          "input": {
            "nums": [0]
          },
          "output": 1,
          "explanation": "1 is missing from [0,1]"
        },
        {
          "id": 5,
          "input": {
            "nums": [1]
          },
          "output": 0,
          "explanation": "0 is missing from [0,1]"
        }
      ],
      "constraints": {
        "n == nums.length": true,
        "1 <= n <= 104": true,
        "0 <= nums[i] <= n": true,
        "All numbers are unique": true
      }
    },
    "20": {
      "title": "Reverse Bits",
      "description": "Given a 32-bit unsigned integer n, reverse the bits of the binary representation of n and return the result.",
      "cases": [
        {
          "id": 1,
          "input": {
            "n": "00000010100101000001111010011100"
          },
          "output": "00111001011110000010100101000000",
          "explanation": "The input binary string is reversed"
        },
        {
          "id": 2,
          "input": {
            "n": "11111111111111111111111111111101"
          },
          "output": "10111111111111111111111111111111",
          "explanation": "Reverse with many 1's"
        },
        {
          "id": 3,
          "input": {
            "n": "00000000000000000000000000000000"
          },
          "output": "00000000000000000000000000000000",
          "explanation": "All zeros stays same when reversed"
        },
        {
          "id": 4,
          "input": {
            "n": "11111111111111111111111111111111"
          },
          "output": "11111111111111111111111111111111",
          "explanation": "All ones stays same when reversed"
        },
        {
          "id": 5,
          "input": {
            "n": "10000000000000000000000000000000"
          },
          "output": "00000000000000000000000000000001",
          "explanation": "Single 1 bit moves from start to end"
        }
      ],
      "constraints": {
        "The input must be a binary string of length 32": true
      }
    },
    "21": {
      "title": "Sum of Two Integers",
      "description": "Given two integers a and b, return the sum of the two integers without using the + and - operators.",
      "cases": [
        {
          "id": 1,
          "input": {
            "a": 1,
            "b": 2
          },
          "output": 3,
          "explanation": "Simple positive numbers sum"
        },
        {
          "id": 2,
          "input": {
            "a": -2,
            "b": 3
          },
          "output": 1,
          "explanation": "Positive and negative numbers"
        },
        {
          "id": 3,
          "input": {
            "a": -1,
            "b": -1
          },
          "output": -2,
          "explanation": "Negative numbers sum"
        },
        {
          "id": 4,
          "input": {
            "a": 0,
            "b": 5
          },
          "output": 5,
          "explanation": "Sum with zero"
        },
        {
          "id": 5,
          "input": {
            "a": 10,
            "b": -10
          },
          "output": 0,
          "explanation": "Numbers that sum to zero"
        }
      ],
      "constraints": {
        "-1000 <= a, b <= 1000": true
      }
    },
    "22": {
      "title": "Reverse Linked List",
      "description": "Given two integers a and b, return the sum of the two integers without using the + and - operators.",
      "cases": [
        {
          "id": 1,
          "input": {
            "head": [1, 2, 3, 4, 5]
          },
          "output": [5, 4, 3, 2, 1],
          "explanation": "Standard case reversal"
        },
        {
          "id": 2,
          "input": {
            "head": [1, 2]
          },
          "output": [2, 1],
          "explanation": "Two node reversal"
        },
        {
          "id": 3,
          "input": {
            "head": []
          },
          "output": [],
          "explanation": "Empty list remains empty"
        },
        {
          "id": 4,
          "input": {
            "head": [1]
          },
          "output": [1],
          "explanation": "Single node remains same"
        },
        {
          "id": 5,
          "input": {
            "head": [1, 1, 2, 2, 3]
          },
          "output": [3, 2, 2, 1, 1],
          "explanation": "Reversal with duplicate values"
        }
      ],
      "constraints": {
        "0 <= number of nodes <= 5000": true,
        "-5000 <= Node.val <= 5000": true
      }
    },
    "23": {
      "title": "Merge Two Sorted Lists",
      "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists into one sorted linked list and return the head of the new sorted linked list.\n\nThe new list should be made up of nodes from list1 and list2.",
      "cases": [
        {
          "id": 1,
          "input": {
            "list1": [1, 2, 4],
            "list2": [1, 3, 4]
          },
          "output": [1, 1, 2, 3, 4, 4],
          "explanation": "Merged maintaining sort order"
        },
        {
          "id": 2,
          "input": {
            "list1": [],
            "list2": []
          },
          "output": [],
          "explanation": "Both empty lists"
        },
        {
          "id": 3,
          "input": {
            "list1": [],
            "list2": [0]
          },
          "output": [0],
          "explanation": "One empty list"
        },
        {
          "id": 4,
          "input": {
            "list1": [1, 3, 5],
            "list2": [2, 4, 6]
          },
          "output": [1, 2, 3, 4, 5, 6],
          "explanation": "Alternating merge"
        },
        {
          "id": 5,
          "input": {
            "list1": [1, 1, 1],
            "list2": [2, 2, 2]
          },
          "output": [1, 1, 1, 2, 2, 2],
          "explanation": "Merge with duplicates"
        }
      ],
      "constraints": {
        "Number of nodes in both lists is in range [0, 50]": true,
        "-100 <= Node.val <= 100": true,
        "Both lists are sorted in non-decreasing order": true
      }
    },
    "24": {
      "title": "Reorder List",
      "description": "You are given the head of a singly linked-list.\n\nThe positions of a linked list of length = 7, for example, can initially be represented as:\n\n[0, 1, 2, 3, 4, 5, 6]\n\nReorder the nodes of the linked list to be in the following order:\n\n[0, 6, 1, 5, 2, 4, 3]\n\nNotice that in the general case for a list of length = n, the nodes are reordered to be in the following order:\n\n[0, n-1, 1, n-2, 2, n-3, ...]\n\nYou may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.",
      "cases": [
        {
          "id": 1,
          "input": {
            "head": [1, 2, 3, 4]
          },
          "output": [1, 4, 2, 3],
          "explanation": "Even length list reorder"
        },
        {
          "id": 2,
          "input": {
            "head": [1, 2, 3, 4, 5]
          },
          "output": [1, 5, 2, 4, 3],
          "explanation": "Odd length list reorder"
        },
        {
          "id": 3,
          "input": {
            "head": [1]
          },
          "output": [1],
          "explanation": "Single node remains unchanged"
        },
        {
          "id": 4,
          "input": {
            "head": [1, 2]
          },
          "output": [1, 2],
          "explanation": "Two nodes remain unchanged"
        },
        {
          "id": 5,
          "input": {
            "head": [1, 2, 3]
          },
          "output": [1, 3, 2],
          "explanation": "Three node reorder"
        }
      ],
      "constraints": {
        "Number of nodes is in range [1, 5 Ã— 104]": true,
        "1 <= Node.val <= 1000": true
      }
    },
    "25": {
      "title": "Remove Nth Node From End of List",
      "description": "You are given the beginning of a linked list head, and an integer n.\n\nRemove the nth node from the end of the list and return the beginning of the list.",
      "cases": [
        {
          "id": 1,
          "input": {
            "head": [1, 2, 3, 4, 5],
            "n": 2
          },
          "output": [1, 2, 3, 5],
          "explanation": "Remove 2nd node from end"
        },
        {
          "id": 2,
          "input": {
            "head": [1],
            "n": 1
          },
          "output": [],
          "explanation": "Remove only node"
        },
        {
          "id": 3,
          "input": {
            "head": [1, 2],
            "n": 1
          },
          "output": [1],
          "explanation": "Remove last node"
        },
        {
          "id": 4,
          "input": {
            "head": [1, 2],
            "n": 2
          },
          "output": [2],
          "explanation": "Remove first node"
        },
        {
          "id": 5,
          "input": {
            "head": [1, 2, 3],
            "n": 3
          },
          "output": [2, 3],
          "explanation": "Remove first node of three"
        }
      ],
      "constraints": {
        "Number of nodes is sz": true,
        "1 <= sz <= 30": true,
        "0 <= Node.val <= 100": true,
        "1 <= n <= sz": true
      }
    },
    "26": {
      "title": "Detect Cycle in a Linked List",
      "description": "Given the beginning of a linked list head, return true if there is a cycle in the linked list. Otherwise, return false.\n\nThere is a cycle in a linked list if at least one node in the list can be visited again by following the next pointer.\n\nInternally, index determines the index of the beginning of the cycle, if it exists. The tail node of the list will set its next pointer to the index-th node. If index = -1, then the tail node points to null and no cycle exists.\n\nNote: index is not given to you as a parameter.",
      "cases": [
        {
          "id": 1,
          "input": {
            "head": [3, 2, 0, -4],
            "pos": 1
          },
          "output": true,
          "explanation": "Tail connects to node at position 1"
        },
        {
          "id": 2,
          "input": {
            "head": [1, 2],
            "pos": 0
          },
          "output": true,
          "explanation": "Tail connects to head"
        },
        {
          "id": 3,
          "input": {
            "head": [1],
            "pos": -1
          },
          "output": false,
          "explanation": "Single node without cycle"
        },
        {
          "id": 4,
          "input": {
            "head": [1, 2, 3, 4],
            "pos": -1
          },
          "output": false,
          "explanation": "Linear list without cycle"
        },
        {
          "id": 5,
          "input": {
            "head": [1, 2, 3, 4, 5],
            "pos": 4
          },
          "output": true,
          "explanation": "Cycle at last node"
        }
      ],
      "constraints": {
        "Number of nodes is in range [0, 104]": true,
        "-105 <= Node.val <= 105": true,
        "pos is -1 or a valid index": true
      }
    },
    "27": {
      "title": "Merge K Sorted Lists",
      "description": "You are given an array of k linked lists, where each list is sorted in ascending order.\n\nReturn the sorted linked list that is the result of merging all of the individual linked lists.",
      "cases": [
        {
          "id": 1,
          "input": {
            "lists": [
              [1, 4, 5],
              [1, 3, 4],
              [2, 6]
            ]
          },
          "output": [1, 1, 2, 3, 4, 4, 5, 6],
          "explanation": "Merge multiple lists maintaining order"
        },
        {
          "id": 2,
          "input": {
            "lists": []
          },
          "output": [],
          "explanation": "Empty input array"
        },
        {
          "id": 3,
          "input": {
            "lists": [[]]
          },
          "output": [],
          "explanation": "Single empty list"
        },
        {
          "id": 4,
          "input": {
            "lists": [[1], [2], [3]]
          },
          "output": [1, 2, 3],
          "explanation": "Single element lists"
        },
        {
          "id": 5,
          "input": {
            "lists": [
              [1, 1, 1],
              [1, 1, 1]
            ]
          },
          "output": [1, 1, 1, 1, 1, 1],
          "explanation": "Lists with duplicate values"
        }
      ],
      "constraints": {
        "k == lists.length": true,
        "0 <= k <= 104": true,
        "0 <= lists[i].length <= 500": true,
        "-104 <= lists[i][j] <= 104": true,
        "lists[i] is sorted in ascending order": true
      }
    },
    "28": {
      "title": "Maximum Depth of Binary Tree",
      "description": "Given the root of a binary tree, return its depth.\n\nThe depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [3, 9, 20, null, null, 15, 7]
          },
          "output": 3,
          "explanation": "Depth is 3 (path: 3->20->7)"
        },
        {
          "id": 2,
          "input": {
            "root": [1, null, 2]
          },
          "output": 2,
          "explanation": "Right-skewed tree of depth 2"
        },
        {
          "id": 3,
          "input": {
            "root": []
          },
          "output": 0,
          "explanation": "Empty tree has depth 0"
        },
        {
          "id": 4,
          "input": {
            "root": [1]
          },
          "output": 1,
          "explanation": "Single node has depth 1"
        },
        {
          "id": 5,
          "input": {
            "root": [1, 2, 3, 4, 5, 6, 7]
          },
          "output": 3,
          "explanation": "Complete binary tree"
        }
      ],
      "constraints": {
        "Number of nodes is in range [0, 104]": true,
        "-100 <= Node.val <= 100": true
      }
    },
    "29": {
      "title": "Same Tree",
      "description": "Given the roots of two binary trees p and q, return true if the trees are equivalent; otherwise, return false.\n\nTwo binary trees are considered equivalent if they share the exact same structure and the nodes have the same values.",
      "cases": [
        {
          "id": 1,
          "input": {
            "p": [1, 2, 3],
            "q": [1, 2, 3]
          },
          "output": true,
          "explanation": "Identical structures and values"
        },
        {
          "id": 2,
          "input": {
            "p": [1, 2],
            "q": [1, null, 2]
          },
          "output": false,
          "explanation": "Different structures"
        },
        {
          "id": 3,
          "input": {
            "p": [1, 2, 1],
            "q": [1, 1, 2]
          },
          "output": false,
          "explanation": "Same structure, different values"
        },
        {
          "id": 4,
          "input": {
            "p": [],
            "q": []
          },
          "output": true,
          "explanation": "Both empty trees"
        },
        {
          "id": 5,
          "input": {
            "p": [1],
            "q": [1]
          },
          "output": true,
          "explanation": "Single node trees"
        }
      ],
      "constraints": {
        "Number of nodes in both trees is in range [0, 100]": true,
        "-104 <= Node.val <= 104": true
      }
    },
    "30": {
      "title": "Invert Binary Tree",
      "description": "You are given the root of a binary tree root. Invert the binary tree and return its root.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [4, 2, 7, 1, 3, 6, 9]
          },
          "output": [4, 7, 2, 9, 6, 3, 1],
          "explanation": "Complete tree inversion"
        },
        {
          "id": 2,
          "input": {
            "root": [2, 1, 3]
          },
          "output": [2, 3, 1],
          "explanation": "Simple three node tree"
        },
        {
          "id": 3,
          "input": {
            "root": []
          },
          "output": [],
          "explanation": "Empty tree remains empty"
        },
        {
          "id": 4,
          "input": {
            "root": [1]
          },
          "output": [1],
          "explanation": "Single node remains same"
        },
        {
          "id": 5,
          "input": {
            "root": [1, 2]
          },
          "output": [1, null, 2],
          "explanation": "Left child becomes right child"
        }
      ],
      "constraints": {
        "Number of nodes in range [0, 100]": true,
        "-100 <= Node.val <= 100": true
      }
    },
    "31": {
      "title": "Binary Tree Maximum Path Sum",
      "description": "Given the root of a non-empty binary tree, return the maximum path sum of any non-empty path.\n\nA path in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. A node cannot appear in the sequence more than once. The path does not necessarily need to include the root.\n\nThe path sum of a path is the sum of the node's values in the path.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [1, 2, 3]
          },
          "output": 6,
          "explanation": "Path 2->1->3 gives maximum sum"
        },
        {
          "id": 2,
          "input": {
            "root": [-10, 9, 20, null, null, 15, 7]
          },
          "output": 42,
          "explanation": "Path 15->20->7 gives maximum sum"
        },
        {
          "id": 3,
          "input": {
            "root": [-3]
          },
          "output": -3,
          "explanation": "Single node path"
        },
        {
          "id": 4,
          "input": {
            "root": [2, -1, -2]
          },
          "output": 2,
          "explanation": "Single node is optimal path"
        },
        {
          "id": 5,
          "input": {
            "root": [1, -2, 3]
          },
          "output": 4,
          "explanation": "Path 1->3 is optimal"
        }
      ],
      "constraints": {
        "Number of nodes in range [1, 3 * 104]": true,
        "-1000 <= Node.val <= 1000": true
      }
    },
    "32": {
      "title": "Binary Tree Level Order Traversal",
      "description": "Given a binary tree root, return the level order traversal of it as a nested list, where each sublist contains the values of nodes at a particular level in the tree, from left to right.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [3, 9, 20, null, null, 15, 7]
          },
          "output": [[3], [9, 20], [15, 7]],
          "explanation": "Nodes grouped by level"
        },
        {
          "id": 2,
          "input": {
            "root": [1]
          },
          "output": [[1]],
          "explanation": "Single node tree"
        },
        {
          "id": 3,
          "input": {
            "root": []
          },
          "output": [],
          "explanation": "Empty tree"
        },
        {
          "id": 4,
          "input": {
            "root": [1, 2, 3, 4, 5]
          },
          "output": [[1], [2, 3], [4, 5]],
          "explanation": "Complete binary tree traversal"
        },
        {
          "id": 5,
          "input": {
            "root": [1, null, 2]
          },
          "output": [[1], [2]],
          "explanation": "Tree with missing left child"
        }
      ],
      "constraints": {
        "Number of nodes in range [0, 2000]": true,
        "-1000 <= Node.val <= 1000": true
      }
    },
    "33": {
      "title": "Serialize and Deserialize Binary Tree",
      "description": "Implement an algorithm to serialize and deserialize a binary tree.\n\nSerialization is the process of converting an in-memory structure into a sequence of bits so that it can be stored or sent across a network to be reconstructed later in another computer environment.\n\nYou just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. There is no additional restriction on how your serialization/deserialization algorithm should work.\n\nNote: The input/output format in the examples is the same as how NeetCode serializes a binary tree. You do not necessarily need to follow this format.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [1, 2, 3, null, null, 4, 5]
          },
          "serialized": "1,2,3,null,null,4,5",
          "deserialized": [1, 2, 3, null, null, 4, 5],
          "explanation": "Tree with multiple levels"
        },
        {
          "id": 2,
          "input": {
            "root": []
          },
          "serialized": "",
          "deserialized": [],
          "explanation": "Empty tree"
        },
        {
          "id": 3,
          "input": {
            "root": [1, null, 2]
          },
          "serialized": "1,null,2",
          "deserialized": [1, null, 2],
          "explanation": "Tree with missing left child"
        },
        {
          "id": 4,
          "input": {
            "root": [1, 2, 3, 4]
          },
          "serialized": "1,2,3,4",
          "deserialized": [1, 2, 3, 4],
          "explanation": "Incomplete tree"
        },
        {
          "id": 5,
          "input": {
            "root": [1, 2, 3, null, null, null, 4]
          },
          "serialized": "1,2,3,null,null,null,4",
          "deserialized": [1, 2, 3, null, null, null, 4],
          "explanation": "Tree with nulls"
        }
      ],
      "constraints": {
        "Number of nodes in range [0, 104]": true,
        "-1000 <= Node.val <= 1000": true
      }
    },
    "34": {
      "title": "Subtree of Another Tree",
      "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values as subRoot; otherwise, return false.\n\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [3, 4, 5, 1, 2],
            "subRoot": [4, 1, 2]
          },
          "output": true,
          "explanation": "subRoot matches subtree"
        },
        {
          "id": 2,
          "input": {
            "root": [3, 4, 5, 1, 2, null, null, null, null, 0],
            "subRoot": [4, 1, 2]
          },
          "output": false,
          "explanation": "Additional node prevents match"
        },
        {
          "id": 3,
          "input": {
            "root": [1],
            "subRoot": [1]
          },
          "output": true,
          "explanation": "Single node match"
        },
        {
          "id": 4,
          "input": {
            "root": [1, 2, 3],
            "subRoot": [2]
          },
          "output": true,
          "explanation": "Left subtree matches"
        },
        {
          "id": 5,
          "input": {
            "root": [1, 2, 3],
            "subRoot": [1, 2]
          },
          "output": false,
          "explanation": "Partial match not sufficient"
        }
      ],
      "constraints": {
        "root tree nodes in range [1, 2000]": true,
        "subRoot tree nodes in range [1, 1000]": true,
        "-104 <= Node.val <= 104": true
      }
    },
    "35": {
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "description": "You are given two integer arrays preorder and inorder.\n\n- preorder is the preorder traversal of a binary tree.\n- inorder is the inorder traversal of the same tree.\n\nBoth arrays are of the same size and consist of unique values.\n\nRebuild the binary tree from the preorder and inorder traversals and return its root.",
      "cases": [
        {
          "id": 1,
          "input": {
            "preorder": [3, 9, 20, 15, 7],
            "inorder": [9, 3, 15, 20, 7]
          },
          "output": [3, 9, 20, null, null, 15, 7],
          "explanation": "Standard tree construction"
        },
        {
          "id": 2,
          "input": {
            "preorder": [1],
            "inorder": [1]
          },
          "output": [1],
          "explanation": "Single node tree"
        },
        {
          "id": 3,
          "input": {
            "preorder": [1, 2, 3],
            "inorder": [3, 2, 1]
          },
          "output": [1, 2, null, 3],
          "explanation": "Left-skewed tree"
        },
        {
          "id": 4,
          "input": {
            "preorder": [1, 2, 3],
            "inorder": [1, 2, 3]
          },
          "output": [1, null, 2, null, 3],
          "explanation": "Right-skewed tree"
        },
        {
          "id": 5,
          "input": {
            "preorder": [1, 2],
            "inorder": [2, 1]
          },
          "output": [1, 2],
          "explanation": "Simple two-node tree"
        }
      ],
      "constraints": {
        "1 <= preorder.length <= 3000": true,
        "inorder.length == preorder.length": true,
        "-3000 <= preorder[i] <= 3000": true
      }
    },
    "36": {
      "title": "Implement Trie (Prefix Tree)",
      "description": "A prefix tree (also known as a trie) is a tree data structure used to efficiently store and retrieve keys in a set of strings. Some applications of this data structure include auto-complete and spell checker systems.\n\nImplement the PrefixTree class:\n\n- PrefixTree() Initializes the prefix tree object.\n- void insert(String word) Inserts the string word into the prefix tree.\n- boolean search(String word) Returns true if the string word is in the prefix tree (i.e., was inserted before), and false otherwise.\n- boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.",
      "cases": [
        {
          "id": 1,
          "input": {
            "operations": [
              "Trie",
              "insert",
              "search",
              "search",
              "startsWith",
              "insert",
              "search"
            ],
            "values": [
              [],
              ["apple"],
              ["apple"],
              ["app"],
              ["app"],
              ["app"],
              ["app"]
            ]
          },
          "output": [null, null, true, false, true, null, true],
          "explanation": "Standard trie operations"
        },
        {
          "id": 2,
          "input": {
            "operations": ["Trie", "insert", "search", "startsWith"],
            "values": [[], ["hello"], ["hell"], ["hell"]]
          },
          "output": [null, null, false, true],
          "explanation": "Prefix vs complete word"
        },
        {
          "id": 3,
          "input": {
            "operations": ["Trie", "insert", "insert", "search"],
            "values": [[], ["a"], ["a"], ["a"]]
          },
          "output": [null, null, null, true],
          "explanation": "Single character operations"
        },
        {
          "id": 4,
          "input": {
            "operations": ["Trie", "search", "startsWith"],
            "values": [[], ["a"], ["a"]]
          },
          "output": [null, false, false],
          "explanation": "Empty trie operations"
        },
        {
          "id": 5,
          "input": {
            "operations": [
              "Trie",
              "insert",
              "search",
              "startsWith",
              "startsWith"
            ],
            "values": [[], ["dog"], ["dog"], ["do"], ["d"]]
          },
          "output": [null, null, true, true, true],
          "explanation": "Multiple prefix lengths"
        }
      ],
      "constraints": {
        "1 <= word.length, prefix.length <= 2000": true,
        "word and prefix consist only of lowercase English letters": true
      }
    },
    "37": {
      "title": "Design Add and Search Words Data Structure",
      "description": "Design a data structure that supports adding new words and searching for existing words.\n\nImplement the WordDictionary class:\n\n- void addWord(word) Adds word to the data structure.\n- bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. The word may contain dots '.' where dots can be matched with any letter.",
      "cases": [
        {
          "id": 1,
          "input": {
            "operations": [
              "WordDictionary",
              "addWord",
              "addWord",
              "search",
              "search",
              "search",
              "search"
            ],
            "values": [[], ["bad"], ["dad"], ["pad"], ["bad"], [".ad"], ["b.."]]
          },
          "output": [null, null, null, false, true, true, true],
          "explanation": "Basic operations with wildcards"
        },
        {
          "id": 2,
          "input": {
            "operations": ["WordDictionary", "addWord", "search", "search"],
            "values": [[], ["a"], ["."], ["a"]]
          },
          "output": [null, null, true, true],
          "explanation": "Single character operations"
        },
        {
          "id": 3,
          "input": {
            "operations": ["WordDictionary", "search"],
            "values": [[], ["."]]
          },
          "output": [null, false],
          "explanation": "Empty dictionary search"
        },
        {
          "id": 4,
          "input": {
            "operations": ["WordDictionary", "addWord", "search"],
            "values": [[], ["cat"], ["c.t"]]
          },
          "output": [null, null, true],
          "explanation": "Middle character wildcard"
        },
        {
          "id": 5,
          "input": {
            "operations": ["WordDictionary", "addWord", "search", "search"],
            "values": [[], ["hello"], ["....o"], ["hell."]]
          },
          "output": [null, null, true, true],
          "explanation": "Multiple wildcards"
        }
      ],
      "constraints": {
        "1 <= word.length <= 25": true,
        "word consists of lowercase English letters and '.'": true,
        "At most 104 calls will be made to addWord and search": true
      }
    },
    "38": {
      "title": "Word Search II",
      "description": "Given a 2-D grid of characters board and a list of strings words, return all words that are present in the grid.\n\nFor a word to be present, it must be possible to form the word with a path in the board using horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.",
      "cases": [
        {
          "id": 1,
          "input": {
            "board": [
              ["o", "a", "a", "n"],
              ["e", "t", "a", "e"],
              ["i", "h", "k", "r"],
              ["i", "f", "l", "v"]
            ],
            "words": ["oath", "pea", "eat", "rain"]
          },
          "output": ["eat", "oath"],
          "explanation": "Can find 'eat' and 'oath' in board"
        },
        {
          "id": 2,
          "input": {
            "board": [
              ["a", "b"],
              ["c", "d"]
            ],
            "words": ["abcd"]
          },
          "output": [],
          "explanation": "Cannot find word that requires jumping"
        },
        {
          "id": 3,
          "input": {
            "board": [["a"]],
            "words": ["a"]
          },
          "output": ["a"],
          "explanation": "Single cell board"
        },
        {
          "id": 4,
          "input": {
            "board": [
              ["a", "b"],
              ["c", "d"]
            ],
            "words": ["a", "b", "c", "d"]
          },
          "output": ["a", "b", "c", "d"],
          "explanation": "Single letter words"
        },
        {
          "id": 5,
          "input": {
            "board": [
              ["a", "a"],
              ["a", "a"]
            ],
            "words": ["a", "aa", "aaa", "aaaa"]
          },
          "output": ["a", "aa", "aaa", "aaaa"],
          "explanation": "Repeated character paths"
        }
      ],
      "constraints": {
        "m == board.length": true,
        "n == board[i].length": true,
        "1 <= m, n <= 12": true,
        "1 <= words.length <= 3 * 104": true
      }
    },
    "39": {
      "title": "Find Median from Data Stream",
      "description": "The median is the middle value in a sorted list of integers. For lists of even length, there is no middle value, so the median is the mean of the two middle values.\n\nFor example:\n\n- For arr = [1,2,3], the median is 2.\n- For arr = [1,2], the median is (1 + 2) / 2 = 1.5.\n\nImplement the MedianFinder class:\n\n- MedianFinder() initializes the MedianFinder object.\n- void addNum(int num) adds the integer num from the data stream to the data structure.\n- double findMedian() returns the median of all elements so far.",
      "cases": [
        {
          "id": 1,
          "input": {
            "operations": ["MedianFinder", "addNum", "addNum", "findMedian"],
            "values": [[], [1], [2], []]
          },
          "output": [null, null, null, 1.5],
          "explanation": "Median of [1,2] is 1.5"
        },
        {
          "id": 2,
          "input": {
            "operations": [
              "MedianFinder",
              "addNum",
              "findMedian",
              "addNum",
              "findMedian"
            ],
            "values": [[], [1], [], [2], []]
          },
          "output": [null, null, 1.0, null, 1.5],
          "explanation": "Progressive median calculation"
        },
        {
          "id": 3,
          "input": {
            "operations": [
              "MedianFinder",
              "addNum",
              "addNum",
              "addNum",
              "findMedian"
            ],
            "values": [[], [1], [2], [3], []]
          },
          "output": [null, null, null, null, 2.0],
          "explanation": "Median of odd count array"
        },
        {
          "id": 4,
          "input": {
            "operations": [
              "MedianFinder",
              "addNum",
              "addNum",
              "addNum",
              "addNum",
              "findMedian"
            ],
            "values": [[], [5], [2], [1], [3], []]
          },
          "output": [null, null, null, null, null, 2.5],
          "explanation": "Median with unsorted additions"
        },
        {
          "id": 5,
          "input": {
            "operations": ["MedianFinder", "addNum", "findMedian"],
            "values": [[], [1], []]
          },
          "output": [null, null, 1.0],
          "explanation": "Single number median"
        }
      ],
      "constraints": {
        "-105 <= num <= 105": true,
        "At most 5 * 104 calls will be made": true,
        "There will be at least one element before findMedian is called": true
      }
    },
    "40": {
      "title": "Clone Graph",
      "description": "Given a node in a connected undirected graph, return a deep copy of the graph.\n\nEach node in the graph contains an integer value and a list of its neighbors.\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n\nThe graph is shown in the test cases as an adjacency list. An adjacency list is a mapping of nodes to lists, used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nFor simplicity, node values are numbered from 1 to n, where n is the total number of nodes in the graph. The index of each node within the adjacency list is the same as the node's value (1-indexed).\n\nThe input node will always be the first node in the graph and have 1 as the value.",
      "cases": [
        {
          "id": 1,
          "input": {
            "adjList": [
              [2, 4],
              [1, 3],
              [2, 4],
              [1, 3]
            ]
          },
          "output": [
            [2, 4],
            [1, 3],
            [2, 4],
            [1, 3]
          ],
          "explanation": "Square graph structure preserved"
        },
        {
          "id": 2,
          "input": {
            "adjList": [[]]
          },
          "output": [[]],
          "explanation": "Single node without edges"
        },
        {
          "id": 3,
          "input": {
            "adjList": []
          },
          "output": [],
          "explanation": "Empty graph"
        },
        {
          "id": 4,
          "input": {
            "adjList": [[2], [1]]
          },
          "output": [[2], [1]],
          "explanation": "Two nodes connected"
        },
        {
          "id": 5,
          "input": {
            "adjList": [[2, 3, 4], [1], [1], [1]]
          },
          "output": [[2, 3, 4], [1], [1], [1]],
          "explanation": "Star-shaped graph"
        }
      ],
      "constraints": {
        "Number of nodes in range [0, 100]": true,
        "1 <= Node.val <= 100": true,
        "Node.val is unique for each node": true
      }
    },
    "41": {
      "title": "Course Schedule",
      "description": "You are given an array prerequisites where prerequisites[i] = [a, b] indicates that you must take course b first if you want to take course a.\n\nFor example, the pair [0, 1] indicates that you must take course 1 before taking course 0.\n\nThere are a total of numCourses courses you are required to take, labeled from 0 to numCourses - 1.\n\nReturn true if it is possible to finish all courses; otherwise, return false.",
      "cases": [
        {
          "id": 1,
          "input": {
            "numCourses": 2,
            "prerequisites": [[1, 0]]
          },
          "output": true,
          "explanation": "Take course 0 then 1"
        },
        {
          "id": 2,
          "input": {
            "numCourses": 2,
            "prerequisites": [
              [1, 0],
              [0, 1]
            ]
          },
          "output": false,
          "explanation": "Circular dependency"
        },
        {
          "id": 3,
          "input": {
            "numCourses": 3,
            "prerequisites": [
              [1, 0],
              [2, 1]
            ]
          },
          "output": true,
          "explanation": "Linear dependency chain"
        },
        {
          "id": 4,
          "input": {
            "numCourses": 4,
            "prerequisites": [
              [1, 0],
              [2, 0],
              [3, 1],
              [3, 2]
            ]
          },
          "output": true,
          "explanation": "Multiple prerequisites possible"
        },
        {
          "id": 5,
          "input": {
            "numCourses": 3,
            "prerequisites": []
          },
          "output": true,
          "explanation": "No prerequisites"
        }
      ],
      "constraints": {
        "1 <= numCourses <= 2000": true,
        "0 <= prerequisites.length <= 5000": true,
        "prerequisites[i].length == 2": true
      }
    },
    "42": {
      "title": "Pacific Atlantic Water Flow",
      "description": "You are given a rectangular island heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).\n\nThe island borders the Pacific Ocean from the top and left sides and borders the Atlantic Ocean from the bottom and right sides.\n\nWater can flow in four directions (up, down, left, or right) from a cell to a neighboring cell with height equal to or lower than the current cell. Water can also flow into the ocean from cells adjacent to the ocean.\n\nFind all cells where water can flow from that cell to both the Pacific and Atlantic oceans. Return it as a 2D list where each element is a list [r, c] representing the row and column of the cell. You may return the answer in any order.",
      "cases": [
        {
          "id": 1,
          "input": {
            "heights": [
              [1, 2, 2, 3, 5],
              [3, 2, 3, 4, 4],
              [2, 4, 5, 3, 1],
              [6, 7, 1, 4, 5],
              [5, 1, 1, 2, 4]
            ]
          },
          "output": [
            [0, 4],
            [1, 3],
            [1, 4],
            [2, 2],
            [3, 0],
            [3, 1],
            [4, 0]
          ],
          "explanation": "Points where water flows to both oceans"
        },
        {
          "id": 2,
          "input": {
            "heights": [[1]]
          },
          "output": [[0, 0]],
          "explanation": "Single cell flows to both"
        },
        {
          "id": 3,
          "input": {
            "heights": [
              [1, 1],
              [1, 1]
            ]
          },
          "output": [
            [0, 0],
            [0, 1],
            [1, 0],
            [1, 1]
          ],
          "explanation": "All cells flow to both"
        },
        {
          "id": 4,
          "input": {
            "heights": [
              [1, 2],
              [3, 4]
            ]
          },
          "output": [[1, 1]],
          "explanation": "Only highest point flows to both"
        },
        {
          "id": 5,
          "input": {
            "heights": [
              [10, 10, 10],
              [10, 1, 10],
              [10, 10, 10]
            ]
          },
          "output": [
            [0, 0],
            [0, 1],
            [0, 2],
            [1, 0],
            [1, 2],
            [2, 0],
            [2, 1],
            [2, 2]
          ],
          "explanation": "Border cells and higher elevations"
        }
      ],
      "constraints": {
        "m == heights.length": true,
        "n == heights[i].length": true,
        "1 <= m, n <= 200": true,
        "0 <= heights[i][j] <= 105": true
      }
    },
    "43": {
      "title": "Number of Islands",
      "description": "Given a 2D grid grid where '1' represents land and '0' represents water, count and return the number of islands.\n\nAn island is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water).",
      "cases": [
        {
          "id": 1,
          "input": {
            "grid": [
              ["1", "1", "1", "1", "0"],
              ["1", "1", "0", "1", "0"],
              ["1", "1", "0", "0", "0"],
              ["0", "0", "0", "0", "0"]
            ]
          },
          "output": 1,
          "explanation": "One large island"
        },
        {
          "id": 2,
          "input": {
            "grid": [
              ["1", "1", "0", "0", "0"],
              ["1", "1", "0", "0", "0"],
              ["0", "0", "1", "0", "0"],
              ["0", "0", "0", "1", "1"]
            ]
          },
          "output": 3,
          "explanation": "Three separate islands"
        },
        {
          "id": 3,
          "input": {
            "grid": [["1"]]
          },
          "output": 1,
          "explanation": "Single cell island"
        },
        {
          "id": 4,
          "input": {
            "grid": [["0"]]
          },
          "output": 0,
          "explanation": "No islands"
        },
        {
          "id": 5,
          "input": {
            "grid": [
              ["1", "0", "1"],
              ["0", "1", "0"],
              ["1", "0", "1"]
            ]
          },
          "output": 5,
          "explanation": "Diagonal islands"
        }
      ],
      "constraints": {
        "m == grid.length": true,
        "n == grid[i].length": true,
        "1 <= m, n <= 300": true,
        "grid[i][j] is '0' or '1'": true
      }
    },
    "44": {
      "title": "Graph Valid Tree",
      "description": "Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.",
      "cases": [
        {
          "id": 1,
          "input": {
            "n": 5,
            "edges": [
              [0, 1],
              [0, 2],
              [0, 3],
              [1, 4]
            ]
          },
          "output": true,
          "explanation": "Valid tree structure"
        },
        {
          "id": 2,
          "input": {
            "n": 5,
            "edges": [
              [0, 1],
              [1, 2],
              [2, 3],
              [1, 3],
              [1, 4]
            ]
          },
          "output": false,
          "explanation": "Contains cycle"
        },
        {
          "id": 3,
          "input": {
            "n": 4,
            "edges": [
              [0, 1],
              [2, 3]
            ]
          },
          "output": false,
          "explanation": "Disconnected components"
        },
        {
          "id": 4,
          "input": {
            "n": 1,
            "edges": []
          },
          "output": true,
          "explanation": "Single node tree"
        },
        {
          "id": 5,
          "input": {
            "n": 3,
            "edges": [
              [0, 1],
              [1, 2]
            ]
          },
          "output": true,
          "explanation": "Linear tree"
        }
      ],
      "constraints": {
        "1 <= n <= 2000": true,
        "0 <= edges.length <= 5000": true,
        "edges[i].length == 2": true,
        "0 <= ai, bi < n": true
      }
    },
    "45": {
      "title": "Number of Connected Components in an Undirected Graph",
      "description": "There is an undirected graph with n nodes. There is also an edges array, where edges[i] = [a, b] means that there is an edge between node a and node b in the graph.\n\nThe nodes are numbered from 0 to n - 1.\n\nReturn the total number of connected components in that graph.",
      "cases": [
        {
          "id": 1,
          "input": {
            "n": 5,
            "edges": [
              [0, 1],
              [1, 2],
              [3, 4]
            ]
          },
          "output": 2,
          "explanation": "Two components: [0-1-2] and [3-4]"
        },
        {
          "id": 2,
          "input": {
            "n": 5,
            "edges": [
              [0, 1],
              [1, 2],
              [2, 3],
              [3, 4]
            ]
          },
          "output": 1,
          "explanation": "All nodes connected"
        },
        {
          "id": 3,
          "input": {
            "n": 5,
            "edges": []
          },
          "output": 5,
          "explanation": "No edges, all isolated"
        },
        {
          "id": 4,
          "input": {
            "n": 4,
            "edges": [
              [0, 1],
              [2, 3],
              [1, 2]
            ]
          },
          "output": 1,
          "explanation": "Single component through multiple paths"
        },
        {
          "id": 5,
          "input": {
            "n": 6,
            "edges": [
              [0, 1],
              [2, 3],
              [4, 5]
            ]
          },
          "output": 3,
          "explanation": "Three pairs of connected nodes"
        }
      ],
      "constraints": {
        "1 <= n <= 2000": true,
        "1 <= edges.length <= 5000": true,
        "edges[i].length == 2": true,
        "0 <= ai < bi < n": true
      }
    },
    "46": {
      "title": "Alien Dictionary",
      "description": "There is a foreign language that uses the Latin alphabet, but the order among letters is not 'a', 'b', 'c' ... 'z' as in English.\n\nYou receive a list of non-empty strings words from the dictionary, where the words are sorted lexicographically based on the rules of this new language.\n\nDerive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid orders of letters, return any of them.\n\nA string a is lexicographically smaller than a string b if either of the following is true:\n\n1. The first letter where they differ is smaller in a than in b.\n2. There is no index i such that a[i] != b[i] and a.length < b.length.",
      "cases": [
        {
          "id": 1,
          "input": {
            "words": ["wrt", "wrf", "er", "ett", "rftt"]
          },
          "output": "wertf",
          "explanation": "Letters ordered based on word comparisons"
        },
        {
          "id": 2,
          "input": {
            "words": ["z", "x"]
          },
          "output": "zx",
          "explanation": "Simple two letter ordering"
        },
        {
          "id": 3,
          "input": {
            "words": ["z", "x", "z"]
          },
          "output": "",
          "explanation": "Invalid dictionary (contradiction)"
        },
        {
          "id": 4,
          "input": {
            "words": ["abc", "ab"]
          },
          "output": "",
          "explanation": "Invalid (longer word before prefix)"
        },
        {
          "id": 5,
          "input": {
            "words": ["ac", "ab", "zc", "zb"]
          },
          "output": "acbz",
          "explanation": "Multiple character relationships"
        }
      ],
      "constraints": {
        "1 <= words.length <= 100": true,
        "1 <= words[i].length <= 100": true,
        "words[i] consists of only lowercase English letters": true
      }
    },
    "47": {
      "title": "Climbing Stairs",
      "description": "You are given an integer n representing the number of steps to reach the top of a staircase. You can climb with either 1 or 2 steps at a time.\n\nReturn the number of distinct ways to climb to the top of the staircase.",
      "cases": [
        {
          "id": 1,
          "input": {
            "n": 2
          },
          "output": 2,
          "explanation": "Ways are: 1+1, 2"
        },
        {
          "id": 2,
          "input": {
            "n": 3
          },
          "output": 3,
          "explanation": "Ways are: 1+1+1, 1+2, 2+1"
        },
        {
          "id": 3,
          "input": {
            "n": 4
          },
          "output": 5,
          "explanation": "Ways are: 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2"
        },
        {
          "id": 4,
          "input": {
            "n": 1
          },
          "output": 1,
          "explanation": "Only one way: 1"
        },
        {
          "id": 5,
          "input": {
            "n": 5
          },
          "output": 8,
          "explanation": "Eight different combinations possible"
        }
      ],
      "constraints": {
        "1 <= n <= 45": true
      }
    },
    "48": {
      "title": "Coin Change",
      "description": "You are given an integer array coins representing coins of different denominations (e.g., 1 dollar, 5 dollars, etc.) and an integer amount representing a target amount of money.\n\nReturn the fewest number of coins that you need to make up the exact target amount. If it is impossible to make up the amount, return -1.\n\nYou may assume that you have an unlimited number of each coin.",
      "cases": [
        {
          "id": 1,
          "input": {
            "coins": [1, 2, 5],
            "amount": 11
          },
          "output": 3,
          "explanation": "5 + 5 + 1 = 11"
        },
        {
          "id": 2,
          "input": {
            "coins": [2],
            "amount": 3
          },
          "output": -1,
          "explanation": "Cannot make amount with given coins"
        },
        {
          "id": 3,
          "input": {
            "coins": [1],
            "amount": 0
          },
          "output": 0,
          "explanation": "Zero amount needs zero coins"
        },
        {
          "id": 4,
          "input": {
            "coins": [1, 2, 5, 10],
            "amount": 18
          },
          "output": 4,
          "explanation": "10 + 5 + 2 + 1 = 18"
        },
        {
          "id": 5,
          "input": {
            "coins": [186, 419, 83, 408],
            "amount": 6249
          },
          "output": 20,
          "explanation": "Complex coin combination"
        }
      ],
      "constraints": {
        "1 <= coins.length <= 12": true,
        "1 <= coins[i] <= 231 - 1": true,
        "0 <= amount <= 104": true
      }
    },
    "49": {
      "title": "Longest Increasing Subsequence",
      "description": "Given a string s, return the longest substring of s that is a palindrome.\n\nA palindrome is a string that reads the same forward and backward.\n\nIf there are multiple palindromic substrings that have the same length, return any one of them.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [10, 9, 2, 5, 3, 7, 101, 18]
          },
          "output": 4,
          "explanation": "Longest sequence is [2,3,7,101]"
        },
        {
          "id": 2,
          "input": {
            "nums": [0, 1, 0, 3, 2, 3]
          },
          "output": 4,
          "explanation": "Longest sequence is [0,1,2,3]"
        },
        {
          "id": 3,
          "input": {
            "nums": [7, 7, 7, 7, 7]
          },
          "output": 1,
          "explanation": "All elements same, max length is 1"
        },
        {
          "id": 4,
          "input": {
            "nums": [1]
          },
          "output": 1,
          "explanation": "Single element array"
        },
        {
          "id": 5,
          "input": {
            "nums": [4, 10, 4, 3, 8, 9]
          },
          "output": 3,
          "explanation": "Sequence is [3,8,9]"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 2500": true,
        "-104 <= nums[i] <= 104": true
      }
    },
    "50": {
      "title": "Word Break",
      "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of dictionary words.\n\nYou are allowed to reuse words in the dictionary an unlimited number of times. You may assume all dictionary words are unique.",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "leetcode",
            "wordDict": ["leet", "code"]
          },
          "output": true,
          "explanation": "Split into 'leet' and 'code'"
        },
        {
          "id": 2,
          "input": {
            "s": "applepenapple",
            "wordDict": ["apple", "pen"]
          },
          "output": true,
          "explanation": "Split into 'apple', 'pen', 'apple'"
        },
        {
          "id": 3,
          "input": {
            "s": "catsandog",
            "wordDict": ["cats", "dog", "sand", "and", "cat"]
          },
          "output": false,
          "explanation": "Cannot be segmented completely"
        },
        {
          "id": 4,
          "input": {
            "s": "a",
            "wordDict": ["a"]
          },
          "output": true,
          "explanation": "Single character word"
        },
        {
          "id": 5,
          "input": {
            "s": "aaaaaaa",
            "wordDict": ["aaa", "aaaa"]
          },
          "output": true,
          "explanation": "Multiple possible segmentations"
        }
      ],
      "constraints": {
        "1 <= s.length <= 300": true,
        "1 <= wordDict.length <= 1000": true,
        "1 <= wordDict[i].length <= 20": true
      }
    },
    "51": {
      "title": "Combination Sum",
      "description": "You are given an array of distinct integers nums and a target integer target. Your task is to return a list of all unique combinations of nums where the chosen numbers sum to target.\n\nThe same number may be chosen from nums an unlimited number of times. Two combinations are the same if the frequency of each of the chosen numbers is the same; otherwise, they are different.\n\nYou may return the combinations in any order, and the order of the numbers in each combination can be in any order.",
      "cases": [
        {
          "id": 1,
          "input": {
            "candidates": [2, 3, 6, 7],
            "target": 7
          },
          "output": [[2, 2, 3], [7]],
          "explanation": "All possible combinations that sum to 7"
        },
        {
          "id": 2,
          "input": {
            "candidates": [2, 3, 5],
            "target": 8
          },
          "output": [
            [2, 2, 2, 2],
            [2, 3, 3],
            [3, 5]
          ],
          "explanation": "Multiple combinations possible"
        },
        {
          "id": 3,
          "input": {
            "candidates": [2],
            "target": 1
          },
          "output": [],
          "explanation": "No possible combinations"
        },
        {
          "id": 4,
          "input": {
            "candidates": [1],
            "target": 1
          },
          "output": [[1]],
          "explanation": "Single number combination"
        },
        {
          "id": 5,
          "input": {
            "candidates": [1, 2, 3],
            "target": 4
          },
          "output": [
            [1, 1, 1, 1],
            [1, 1, 2],
            [2, 2],
            [1, 3]
          ],
          "explanation": "Multiple ways using small numbers"
        }
      ],
      "constraints": {
        "1 <= candidates.length <= 30": true,
        "2 <= target <= 40": true,
        "All elements are unique": true
      }
    },
    "52": {
      "title": "House Robber",
      "description": "You are given an integer array nums where nums[i] represents the amount of money the ith house has. The houses are arranged in a straight line, meaning the ith house is the neighbor of the (i-1)th and (i+1)th house.\n\nYou are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.\n\nReturn the maximum amount of money you can rob without alerting the police.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [1, 2, 3, 1]
          },
          "output": 4,
          "explanation": "Rob house 1 (money = 1) and house 3 (money = 3)"
        },
        {
          "id": 2,
          "input": {
            "nums": [2, 7, 9, 3, 1]
          },
          "output": 12,
          "explanation": "Rob houses 2 (7) and 4 (3) and 5 (1)"
        },
        {
          "id": 3,
          "input": {
            "nums": [2, 1, 1, 2]
          },
          "output": 4,
          "explanation": "Rob first and last houses"
        },
        {
          "id": 4,
          "input": {
            "nums": [1]
          },
          "output": 1,
          "explanation": "Only one house to rob"
        },
        {
          "id": 5,
          "input": {
            "nums": [1, 2]
          },
          "output": 2,
          "explanation": "Rob house with more money"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 100": true,
        "0 <= nums[i] <= 400": true
      }
    },
    "53": {
      "title": "House Robber II",
      "description": "You are given an integer array nums where nums[i] represents the amount of money the ith house has. The houses are arranged in a circle, meaning the first house and the last house are neighbors.\n\nYou are planning to rob money from the houses, but you cannot rob two adjacent houses because the security system will automatically alert the police if two adjacent houses were both broken into.\n\nReturn the maximum amount of money you can rob without alerting the police.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [2, 3, 2]
          },
          "output": 3,
          "explanation": "Cannot rob first and last house"
        },
        {
          "id": 2,
          "input": {
            "nums": [1, 2, 3, 1]
          },
          "output": 4,
          "explanation": "Rob house 2 and 4"
        },
        {
          "id": 3,
          "input": {
            "nums": [1, 2, 3]
          },
          "output": 3,
          "explanation": "Rob the house with max money"
        },
        {
          "id": 4,
          "input": {
            "nums": [1]
          },
          "output": 1,
          "explanation": "Only one house to rob"
        },
        {
          "id": 5,
          "input": {
            "nums": [200, 3, 140, 20, 10]
          },
          "output": 340,
          "explanation": "Rob houses with 200 and 140"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 100": true,
        "0 <= nums[i] <= 1000": true
      }
    },
    "54": {
      "title": "Decode Ways",
      "description": "A string consisting of uppercase English characters can be encoded to a number using the following mapping:\n\n- 'A' -> \"1\"\n- 'B' -> \"2\"\n...\n- 'Z' -> \"26\"\n\nTo decode a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above. There may be multiple ways to decode a message. For example, \"1012\" can be mapped into:\n\n- \"JAB\" with the grouping (10 1 2)\n- \"JL\" with the grouping (10 12)\n\nThe grouping (1 01 2) is invalid because 01 cannot be mapped into a letter since it contains a leading zero.\n\nGiven a string s containing only digits, return the number of ways to decode it. You can assume that the answer fits in a 32-bit integer.",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "12"
          },
          "output": 2,
          "explanation": "Can be decoded as 'AB' (1,2) or 'L' (12)"
        },
        {
          "id": 2,
          "input": {
            "s": "226"
          },
          "output": 3,
          "explanation": "Can be decoded as (2,2,6), (22,6), or (2,26)"
        },
        {
          "id": 3,
          "input": {
            "s": "06"
          },
          "output": 0,
          "explanation": "Cannot decode: leading zero invalid"
        },
        {
          "id": 4,
          "input": {
            "s": "27"
          },
          "output": 1,
          "explanation": "Only one way: (2,7) as 27 > 26"
        },
        {
          "id": 5,
          "input": {
            "s": "1201234"
          },
          "output": 3,
          "explanation": "Multiple valid decodings with zero"
        }
      ],
      "constraints": {
        "1 <= s.length <= 100": true,
        "s contains only digits": true,
        "s[0] cannot be '0'": true
      }
    },
    "55": {
      "title": "Unique Paths",
      "description": "There is an m x n grid where you are allowed to move either down or to the right at any point in time.\n\nGiven the two integers m and n, return the number of possible unique paths that can be taken from the top-left corner of the grid (grid[0][0]) to the bottom-right corner (grid[m - 1][n - 1]).\n\nYou may assume the output will fit in a 32-bit integer.",
      "cases": [
        {
          "id": 1,
          "input": {
            "m": 3,
            "n": 7
          },
          "output": 28,
          "explanation": "28 different possible paths"
        },
        {
          "id": 2,
          "input": {
            "m": 3,
            "n": 2
          },
          "output": 3,
          "explanation": "Three possible paths"
        },
        {
          "id": 3,
          "input": {
            "m": 1,
            "n": 1
          },
          "output": 1,
          "explanation": "Start cell is also end cell"
        },
        {
          "id": 4,
          "input": {
            "m": 3,
            "n": 3
          },
          "output": 6,
          "explanation": "Six possible paths in square grid"
        },
        {
          "id": 5,
          "input": {
            "m": 4,
            "n": 4
          },
          "output": 20,
          "explanation": "Twenty paths in larger square"
        }
      ],
      "constraints": {
        "1 <= m, n <= 100": true,
        "Answer will be less than or equal to 2 * 109": true
      }
    },
    "56": {
      "title": "Jump Game",
      "description": "You are given an integer array nums where each element nums[i] indicates your maximum jump length at that position.\n\nReturn true if you can reach the last index starting from index 0, or false otherwise.",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [2, 3, 1, 1, 4]
          },
          "output": true,
          "explanation": "Jump 1 step from index 0 to 1, then 3 steps to last index"
        },
        {
          "id": 2,
          "input": {
            "nums": [3, 2, 1, 0, 4]
          },
          "output": false,
          "explanation": "Stuck at index 3 with zero jump power"
        },
        {
          "id": 3,
          "input": {
            "nums": [0]
          },
          "output": true,
          "explanation": "Already at last index"
        },
        {
          "id": 4,
          "input": {
            "nums": [1, 1, 1, 1]
          },
          "output": true,
          "explanation": "Can reach end with consecutive jumps"
        },
        {
          "id": 5,
          "input": {
            "nums": [2, 0, 0]
          },
          "output": true,
          "explanation": "Can jump over zeros"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 104": true,
        "0 <= nums[i] <= 105": true
      }
    },
    "57": {
      "title": "Longest Common Subsequence",
      "description": "Given two strings text1 and text2, return the length of the longest common subsequence between the two strings if one exists; otherwise, return 0.\n\nA subsequence is a sequence that can be derived from the given sequence by deleting some or no elements without changing the relative order of the remaining characters.\n\nFor example, \"cat\" is a subsequence of \"crabt\".\n\nA common subsequence of two strings is a subsequence that exists in both strings.",
      "cases": [
        {
          "id": 1,
          "input": {
            "text1": "abcde",
            "text2": "ace"
          },
          "output": 3,
          "explanation": "LCS is 'ace'"
        },
        {
          "id": 2,
          "input": {
            "text1": "abc",
            "text2": "abc"
          },
          "output": 3,
          "explanation": "Identical strings"
        },
        {
          "id": 3,
          "input": {
            "text1": "abc",
            "text2": "def"
          },
          "output": 0,
          "explanation": "No common characters"
        },
        {
          "id": 4,
          "input": {
            "text1": "aaaaaa",
            "text2": "aaa"
          },
          "output": 3,
          "explanation": "Repeated characters"
        },
        {
          "id": 5,
          "input": {
            "text1": "bsbininm",
            "text2": "jmjkbkjk"
          },
          "output": 1,
          "explanation": "Complex pattern matching"
        }
      ],
      "constraints": {
        "1 <= text1.length, text2.length <= 1000": true,
        "text1 and text2 consist of only lowercase English characters": true
      }
    },
    "58": {
      "title": "Insert Interval",
      "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] represents the start and the end time of the ith interval. intervals is initially sorted in ascending order by start_i.\n\nYou are given another interval newInterval = [start, end].\n\nInsert newInterval into intervals such that intervals is still sorted in ascending order by start_i and also intervals still does not have any overlapping intervals. You may merge the overlapping intervals if needed.\n\nReturn intervals after adding newInterval.\n\nNote: Intervals are non-overlapping if they have no common point. For example, [1,2] and [3,4] are non-overlapping, but [1,2] and [2,3] are overlapping.",
      "cases": [
        {
          "id": 1,
          "input": {
            "intervals": [
              [1, 3],
              [6, 9]
            ],
            "newInterval": [2, 5]
          },
          "output": [
            [1, 5],
            [6, 9]
          ],
          "explanation": "Merge overlapping interval"
        },
        {
          "id": 2,
          "input": {
            "intervals": [
              [1, 2],
              [3, 5],
              [6, 7],
              [8, 10],
              [12, 16]
            ],
            "newInterval": [4, 8]
          },
          "output": [
            [1, 2],
            [3, 10],
            [12, 16]
          ],
          "explanation": "Merge multiple overlapping intervals"
        },
        {
          "id": 3,
          "input": {
            "intervals": [],
            "newInterval": [5, 7]
          },
          "output": [[5, 7]],
          "explanation": "Insert into empty list"
        },
        {
          "id": 4,
          "input": {
            "intervals": [[1, 5]],
            "newInterval": [6, 8]
          },
          "output": [
            [1, 5],
            [6, 8]
          ],
          "explanation": "Non-overlapping insertion"
        },
        {
          "id": 5,
          "input": {
            "intervals": [[1, 5]],
            "newInterval": [0, 3]
          },
          "output": [[0, 5]],
          "explanation": "Merge with overlap at start"
        }
      ],
      "constraints": {
        "0 <= intervals.length <= 104": true,
        "intervals[i].length == 2": true,
        "0 <= intervals[i][0] <= intervals[i][1] <= 105": true
      }
    },
    "59": {
      "title": "Merge Intervals",
      "description": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nYou may return the answer in any order.\n\nNote: Intervals are non-overlapping if they have no common point. For example, [1, 2] and [3, 4] are non-overlapping, but [1, 2] and [2, 3] are overlapping.",
      "cases": [
        {
          "id": 1,
          "input": {
            "intervals": [
              [1, 3],
              [2, 6],
              [8, 10],
              [15, 18]
            ]
          },
          "output": [
            [1, 6],
            [8, 10],
            [15, 18]
          ],
          "explanation": "Merge [1,3] and [2,6]"
        },
        {
          "id": 2,
          "input": {
            "intervals": [
              [1, 4],
              [4, 5]
            ]
          },
          "output": [[1, 5]],
          "explanation": "Intervals touching should merge"
        },
        {
          "id": 3,
          "input": {
            "intervals": [
              [1, 4],
              [0, 4]
            ]
          },
          "output": [[0, 4]],
          "explanation": "Completely overlapping intervals"
        },
        {
          "id": 4,
          "input": {
            "intervals": [[1, 4]]
          },
          "output": [[1, 4]],
          "explanation": "Single interval remains unchanged"
        },
        {
          "id": 5,
          "input": {
            "intervals": [
              [1, 4],
              [0, 0]
            ]
          },
          "output": [
            [0, 0],
            [1, 4]
          ],
          "explanation": "Non-overlapping intervals stay separate"
        }
      ],
      "constraints": {
        "1 <= intervals.length <= 104": true,
        "intervals[i].length == 2": true,
        "0 <= starti <= endi <= 104": true
      }
    },
    "60": {
      "title": "Non-overlapping Intervals",
      "description": "Given an array of intervals intervals where intervals[i] = [start_i, end_i], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nNote: Intervals are non-overlapping even if they have a common point. For example, [1, 3] and [2, 4] are overlapping, but [1, 2] and [2, 3] are non-overlapping.",
      "cases": [
        {
          "id": 1,
          "input": {
            "intervals": [
              [1, 2],
              [2, 3],
              [3, 4],
              [1, 3]
            ]
          },
          "output": 1,
          "explanation": "Remove [1,3] to make non-overlapping"
        },
        {
          "id": 2,
          "input": {
            "intervals": [
              [1, 2],
              [1, 2],
              [1, 2]
            ]
          },
          "output": 2,
          "explanation": "Remove two duplicate intervals"
        },
        {
          "id": 3,
          "input": {
            "intervals": [
              [1, 2],
              [2, 3]
            ]
          },
          "output": 0,
          "explanation": "Already non-overlapping"
        },
        {
          "id": 4,
          "input": {
            "intervals": [
              [1, 100],
              [11, 22],
              [1, 11],
              [2, 12]
            ]
          },
          "output": 2,
          "explanation": "Remove two overlapping intervals"
        },
        {
          "id": 5,
          "input": {
            "intervals": [
              [0, 2],
              [1, 3],
              [2, 4],
              [3, 5],
              [4, 6]
            ]
          },
          "output": 2,
          "explanation": "Remove intervals to make non-overlapping"
        }
      ],
      "constraints": {
        "1 <= intervals.length <= 105": true,
        "intervals[i].length == 2": true,
        "-5 * 104 <= starti < endi <= 5 * 104": true
      }
    },
    "61": {
      "title": "Meeting Rooms",
      "description": "Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), determine if a person could add all meetings to their schedule without any conflicts.",
      "cases": [
        {
          "id": 1,
          "input": {
            "intervals": [
              [0, 30],
              [5, 10],
              [15, 20]
            ]
          },
          "output": false,
          "explanation": "Meetings at [0,30] and [5,10] overlap"
        },
        {
          "id": 2,
          "input": {
            "intervals": [
              [7, 10],
              [2, 4]
            ]
          },
          "output": true,
          "explanation": "No overlapping meetings"
        },
        {
          "id": 3,
          "input": {
            "intervals": [
              [1, 2],
              [2, 3]
            ]
          },
          "output": true,
          "explanation": "Back-to-back meetings are possible"
        },
        {
          "id": 4,
          "input": {
            "intervals": [
              [1, 5],
              [5, 10]
            ]
          },
          "output": true,
          "explanation": "Meetings exactly touching are allowed"
        },
        {
          "id": 5,
          "input": {
            "intervals": [
              [9, 10],
              [4, 9],
              [4, 17]
            ]
          },
          "output": false,
          "explanation": "Multiple overlapping meetings"
        }
      ],
      "constraints": {
        "0 <= intervals.length <= 104": true,
        "intervals[i].length == 2": true,
        "0 <= starti < endi <= 106": true
      }
    },
    "62": {
      "title": "Meeting Rooms II",
      "description": "Given an array of meeting time interval objects consisting of start and end times [[start_1,end_1],[start_2,end_2],...] (start_i < end_i), find the minimum number of days required to schedule all meetings without any conflicts.",
      "cases": [
        {
          "id": 1,
          "input": {
            "intervals": [
              [0, 30],
              [5, 10],
              [15, 20]
            ]
          },
          "output": 2,
          "explanation": "Need 2 rooms for overlapping meetings"
        },
        {
          "id": 2,
          "input": {
            "intervals": [
              [7, 10],
              [2, 4]
            ]
          },
          "output": 1,
          "explanation": "One room sufficient for non-overlapping meetings"
        },
        {
          "id": 3,
          "input": {
            "intervals": [
              [1, 4],
              [4, 5],
              [5, 6]
            ]
          },
          "output": 1,
          "explanation": "Back-to-back meetings need only one room"
        },
        {
          "id": 4,
          "input": {
            "intervals": [
              [1, 4],
              [4, 5],
              [2, 3],
              [3, 6]
            ]
          },
          "output": 2,
          "explanation": "Complex overlapping requires two rooms"
        },
        {
          "id": 5,
          "input": {
            "intervals": [
              [9, 10],
              [4, 9],
              [4, 17],
              [5, 6],
              [1, 2]
            ]
          },
          "output": 3,
          "explanation": "Multiple simultaneous meetings need three rooms"
        }
      ],
      "constraints": {
        "1 <= intervals.length <= 104": true,
        "0 <= starti < endi <= 106": true,
        "intervals[i].length == 2": true
      }
    },
    "63": {
      "title": "Find Minimum in Rotated Sorted Array",
      "description": "You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times.\n\nFor example, the array nums = [1,2,3,4,5,6] might become:\n\n- [3,4,5,6,1,2] if it was rotated 4 times.\n- [1,2,3,4,5,6] if it was rotated 6 times.\n\nNotice that rotating the array 4 times moves the last four elements of the array to the beginning. Rotating the array 6 times produces the original array.\n\nAssuming all elements in the rotated sorted array nums are unique, return the minimum element of this array.\n\nA solution that runs in O(n) time is trivial; can you write an algorithm that runs in O(log n) time?",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [3, 4, 5, 1, 2]
          },
          "output": 1,
          "explanation": "The original array was [1,2,3,4,5] rotated 3 times"
        },
        {
          "id": 2,
          "input": {
            "nums": [4, 5, 6, 7, 0, 1, 2]
          },
          "output": 0,
          "explanation": "The original array was [0,1,2,4,5,6,7] rotated 4 times"
        },
        {
          "id": 3,
          "input": {
            "nums": [11, 13, 15, 17]
          },
          "output": 11,
          "explanation": "The array is already in sorted order"
        },
        {
          "id": 4,
          "input": {
            "nums": [2, 1]
          },
          "output": 1,
          "explanation": "Simple case with two elements"
        },
        {
          "id": 5,
          "input": {
            "nums": [5, 1, 2, 3, 4]
          },
          "output": 1,
          "explanation": "Array rotated once from [1,2,3,4,5]"
        }
      ],
      "constraints": {
        "n == nums.length": true,
        "1 <= n <= 5000": true,
        "-5000 <= nums[i] <= 5000": true,
        "All the integers of nums are unique": true,
        "nums is sorted and rotated between 1 and n times": true
      }
    },
    "64": {
      "title": "Search in Rotated Sorted Array",
      "description": "You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times.\n\nFor example, the array nums = [1,2,3,4,5,6] might become:\n\n- [3,4,5,6,1,2] if it was rotated 4 times.\n- [1,2,3,4,5,6] if it was rotated 6 times.\n\nNotice that rotating the array 4 times moves the last four elements of the array to the beginning. Rotating the array 6 times produces the original array.\n\nAssuming all elements in the rotated sorted array nums are unique, return the minimum element of this array.\n\nA solution that runs in O(n) time is trivial; can you write an algorithm that runs in O(log n) time?",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [4, 5, 6, 7, 0, 1, 2],
            "target": 0
          },
          "output": 4,
          "explanation": "Target 0 is found at index 4"
        },
        {
          "id": 2,
          "input": {
            "nums": [4, 5, 6, 7, 0, 1, 2],
            "target": 3
          },
          "output": -1,
          "explanation": "Target 3 is not in the array"
        },
        {
          "id": 3,
          "input": {
            "nums": [1],
            "target": 0
          },
          "output": -1,
          "explanation": "Single element array, target not found"
        },
        {
          "id": 4,
          "input": {
            "nums": [3, 1],
            "target": 1
          },
          "output": 1,
          "explanation": "Target found in small rotated array"
        },
        {
          "id": 5,
          "input": {
            "nums": [5, 1, 3],
            "target": 5
          },
          "output": 0,
          "explanation": "Target found at beginning of rotated array"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 5000": true,
        "-10^4 <= nums[i] <= 10^4": true,
        "All values of nums are unique": true,
        "nums is sorted and rotated between 1 and n times": true,
        "-10^4 <= target <= 10^4": true
      }
    },
    "65": {
      "title": "Lowest Common Ancestor of a Binary Search Tree",
      "description": "Given a binary search tree (BST) where all node values are unique, and two nodes from the tree p and q, return the lowest common ancestor (LCA) of the two nodes.\n\nThe lowest common ancestor between two nodes p and q is the lowest node in a tree T such that both p and q are descendants. The ancestor is allowed to be a descendant of itself.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
            "p": 2,
            "q": 8
          },
          "output": 6,
          "explanation": "The LCA of nodes 2 and 8 is 6"
        },
        {
          "id": 2,
          "input": {
            "root": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
            "p": 2,
            "q": 4
          },
          "output": 2,
          "explanation": "The LCA of nodes 2 and 4 is 2 since 2 is ancestor of 4"
        },
        {
          "id": 3,
          "input": {
            "root": [2, 1],
            "p": 2,
            "q": 1
          },
          "output": 2,
          "explanation": "Simple tree with root as LCA"
        },
        {
          "id": 4,
          "input": {
            "root": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5],
            "p": 3,
            "q": 5
          },
          "output": 4,
          "explanation": "LCA of nodes in same subtree"
        },
        {
          "id": 5,
          "input": {
            "root": [6, 2, 8, 0, 4, 7, 9],
            "p": 7,
            "q": 9
          },
          "output": 8,
          "explanation": "LCA of nodes in right subtree"
        }
      ],
      "constraints": {
        "The number of nodes in the tree is in the range [2, 105]": true,
        "-109 <= Node.val <= 109": true,
        "All Node.val are unique": true,
        "p != q": true,
        "p and q exist in the BST": true
      }
    },
    "66": {
      "title": "Validate Binary Search Tree",
      "description": "Given the root of a binary tree, return true if it is a valid binary search tree; otherwise, return false.\n\nA valid binary search tree satisfies the following constraints:\n\n- The left subtree of every node contains only nodes with keys less than the node's key.\n- The right subtree of every node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees are also binary search trees.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [2, 1, 3]
          },
          "output": true,
          "explanation": "Valid BST with root > left child and root < right child"
        },
        {
          "id": 2,
          "input": {
            "root": [5, 1, 4, null, null, 3, 6]
          },
          "output": false,
          "explanation": "Root is 5, but value 4 has right child 6 > 5"
        },
        {
          "id": 3,
          "input": {
            "root": [5, 4, 6, null, null, 3, 7]
          },
          "output": false,
          "explanation": "Value 3 in right subtree is less than root 5"
        },
        {
          "id": 4,
          "input": {
            "root": [2, 2, 2]
          },
          "output": false,
          "explanation": "Duplicate values are not allowed in BST"
        },
        {
          "id": 5,
          "input": {
            "root": [3, 1, 5, 0, 2, 4, 6]
          },
          "output": true,
          "explanation": "Perfect BST with all values in correct order"
        }
      ],
      "constraints": {
        "The number of nodes in the tree is in the range [1, 104]": true,
        "-231 <= Node.val <= 231 - 1": true,
        "Each node has a unique value": true
      }
    },
    "67": {
      "title": "Kth Smallest Element in a BST",
      "description": "Given the root of a binary search tree and an integer k, return the kth smallest value (1-indexed) in the tree.\n\nA binary search tree satisfies the following constraints:\n\n- The left subtree of every node contains only nodes with keys less than the node's key.\n- The right subtree of every node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees are also binary search trees.",
      "cases": [
        {
          "id": 1,
          "input": {
            "root": [3, 1, 4, null, 2],
            "k": 1
          },
          "output": 1,
          "explanation": "The smallest element in the BST"
        },
        {
          "id": 2,
          "input": {
            "root": [5, 3, 6, 2, 4, null, null, 1],
            "k": 3
          },
          "output": 3,
          "explanation": "In-order traversal gives [1,2,3,4,5,6], 3rd element is 3"
        },
        {
          "id": 3,
          "input": {
            "root": [1],
            "k": 1
          },
          "output": 1,
          "explanation": "Single node tree, k=1 returns the only value"
        },
        {
          "id": 4,
          "input": {
            "root": [3, 1, 4, null, 2],
            "k": 4
          },
          "output": 4,
          "explanation": "In-order traversal gives [1,2,3,4], 4th element is 4"
        },
        {
          "id": 5,
          "input": {
            "root": [5, 3, 6, 2, 4, null, null, 1],
            "k": 6
          },
          "output": 6,
          "explanation": "Kth element is the largest in the tree"
        }
      ],
      "constraints": {
        "The number of nodes in the tree is n": true,
        "1 <= k <= n <= 104": true,
        "0 <= Node.val <= 104": true,
        "The tree is guaranteed to be a valid BST": true
      }
    },
    "68": {
      "title": "Word Search",
      "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring",
      "cases": [
        {
          "id": 1,
          "input": {
            "board": [
              ["A", "B", "C", "E"],
              ["S", "F", "C", "S"],
              ["A", "D", "E", "E"]
            ],
            "word": "ABCCED"
          },
          "output": true,
          "explanation": "Path can be formed: Aâ†’Bâ†’Câ†’Câ†’Eâ†’D"
        },
        {
          "id": 2,
          "input": {
            "board": [
              ["A", "B", "C", "E"],
              ["S", "F", "C", "S"],
              ["A", "D", "E", "E"]
            ],
            "word": "SEE"
          },
          "output": true,
          "explanation": "Path can be formed: Sâ†’Eâ†’E"
        },
        {
          "id": 3,
          "input": {
            "board": [
              ["A", "B", "C", "E"],
              ["S", "F", "C", "S"],
              ["A", "D", "E", "E"]
            ],
            "word": "ABCB"
          },
          "output": false,
          "explanation": "Cannot reuse same cell to form path"
        },
        {
          "id": 4,
          "input": {
            "board": [["A"]],
            "word": "A"
          },
          "output": true,
          "explanation": "Single character board and word match"
        },
        {
          "id": 5,
          "input": {
            "board": [
              ["C", "A", "A"],
              ["A", "A", "A"],
              ["B", "C", "D"]
            ],
            "word": "AAB"
          },
          "output": true,
          "explanation": "Path can be formed even with multiple possible routes"
        }
      ],
      "constraints": {
        "m == board.length": true,
        "n = board[i].length": true,
        "1 <= m, n <= 6": true,
        "1 <= word.length <= 15": true,
        "board and word consists of only lowercase and uppercase English letters": true,
        "Same letter cell may not be used more than once": true
      }
    },
    "69": {
      "title": "Maximum Subarray",
      "description": "Find the contiguous subarray (containing at least one number) which has the largest sum and return its sum",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [-2, 1, -3, 4, -1, 2, 1, -5, 4]
          },
          "output": 6,
          "explanation": "The contiguous subarray [4,-1,2,1] has the largest sum = 6"
        },
        {
          "id": 2,
          "input": {
            "nums": [1]
          },
          "output": 1,
          "explanation": "Single element array, the element itself is the maximum subarray"
        },
        {
          "id": 3,
          "input": {
            "nums": [5, 4, -1, 7, 8]
          },
          "output": 23,
          "explanation": "The entire array is the maximum subarray with sum = 23"
        },
        {
          "id": 4,
          "input": {
            "nums": [-1, -2, -3, -4]
          },
          "output": -1,
          "explanation": "All negative numbers, the maximum subarray contains the least negative number"
        },
        {
          "id": 5,
          "input": {
            "nums": [-2, 1, -3, 4, -1, 2, 1, -5, 4, -10, 12]
          },
          "output": 12,
          "explanation": "The subarray [12] has the largest sum, showing that earlier elements can be ignored if they reduce the sum"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 105": true,
        "-104 <= nums[i] <= 104": true,
        "Array must contain at least one element": true
      }
    },
    "70": {
      "title": "Longest Palindromic Substring",
      "description": "Given a string s, return the longest palindromic substring in s",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "babad"
          },
          "output": "bab",
          "explanation": "Both 'bab' and 'aba' are valid answers"
        },
        {
          "id": 2,
          "input": {
            "s": "cbbd"
          },
          "output": "bb",
          "explanation": "The longest palindromic substring is 'bb'"
        },
        {
          "id": 3,
          "input": {
            "s": "a"
          },
          "output": "a",
          "explanation": "Single character is always a palindrome"
        },
        {
          "id": 4,
          "input": {
            "s": "aaaaaa"
          },
          "output": "aaaaaa",
          "explanation": "Entire string is a palindrome"
        },
        {
          "id": 5,
          "input": {
            "s": "abcda"
          },
          "output": "a",
          "explanation": "When no longer palindromes exist, return any single character"
        }
      ],
      "constraints": {
        "1 <= s.length <= 1000": true,
        "s consist of only digits and English letters": true
      }
    },
    "71": {
      "title": "Palindromic Substrings",
      "description": "Given a string s, return the number of palindromic substrings in it",
      "cases": [
        {
          "id": 1,
          "input": {
            "s": "abc"
          },
          "output": 3,
          "explanation": "Palindromic substrings are: 'a', 'b', 'c'"
        },
        {
          "id": 2,
          "input": {
            "s": "aaa"
          },
          "output": 6,
          "explanation": "Palindromic substrings are: 'a', 'a', 'a', 'aa', 'aa', 'aaa'"
        },
        {
          "id": 3,
          "input": {
            "s": "aba"
          },
          "output": 4,
          "explanation": "Palindromic substrings are: 'a', 'b', 'a', 'aba'"
        },
        {
          "id": 4,
          "input": {
            "s": "abba"
          },
          "output": 6,
          "explanation": "Palindromic substrings are: 'a', 'b', 'b', 'a', 'bb', 'abba'"
        },
        {
          "id": 5,
          "input": {
            "s": "z"
          },
          "output": 1,
          "explanation": "Single character string has one palindromic substring"
        }
      ],
      "constraints": {
        "1 <= s.length <= 1000": true,
        "s consists of lowercase English letters": true
      }
    },
    "72": {
      "title": "Maximum Product Subarray",
      "description": "Find the contiguous subarray within an array that has the largest product",
      "cases": [
        {
          "id": 1,
          "input": {
            "nums": [2, 3, -2, 4]
          },
          "output": 6,
          "explanation": "Subarray [2,3] has the largest product = 6"
        },
        {
          "id": 2,
          "input": {
            "nums": [-2, 0, -1]
          },
          "output": 0,
          "explanation": "The maximum product is 0, achieved by the single element [0]"
        },
        {
          "id": 3,
          "input": {
            "nums": [-2, 3, -4]
          },
          "output": 24,
          "explanation": "The entire array has product 24 (negative Ã— positive Ã— negative)"
        },
        {
          "id": 4,
          "input": {
            "nums": [0, 2]
          },
          "output": 2,
          "explanation": "Skip the 0 and take [2] for maximum product"
        },
        {
          "id": 5,
          "input": {
            "nums": [-1, -2, -3, 0]
          },
          "output": 6,
          "explanation": "Subarray [-1,-2,-3] gives maximum product 6"
        }
      ],
      "constraints": {
        "1 <= nums.length <= 2 * 104": true,
        "-10 <= nums[i] <= 10": true,
        "The array contains at least one number": true
      }
    },
    "73": {
      "title": "Rotate Image",
      "description": "Rotate the given n Ã— n 2D matrix by 90 degrees clockwise",
      "cases": [
        {
          "id": 1,
          "input": {
            "matrix": [
              [1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]
            ]
          },
          "output": [
            [7, 4, 1],
            [8, 5, 2],
            [9, 6, 3]
          ],
          "explanation": "90-degree clockwise rotation of 3x3 matrix"
        },
        {
          "id": 2,
          "input": {
            "matrix": [
              [5, 1, 9, 11],
              [2, 4, 8, 10],
              [13, 3, 6, 7],
              [15, 14, 12, 16]
            ]
          },
          "output": [
            [15, 13, 2, 5],
            [14, 3, 4, 1],
            [12, 6, 8, 9],
            [16, 7, 10, 11]
          ],
          "explanation": "90-degree clockwise rotation of 4x4 matrix"
        },
        {
          "id": 3,
          "input": {
            "matrix": [[1]]
          },
          "output": [[1]],
          "explanation": "1x1 matrix remains unchanged after rotation"
        },
        {
          "id": 4,
          "input": {
            "matrix": [
              [1, 2],
              [3, 4]
            ]
          },
          "output": [
            [3, 1],
            [4, 2]
          ],
          "explanation": "90-degree clockwise rotation of 2x2 matrix"
        },
        {
          "id": 5,
          "input": {
            "matrix": [
              [1, 2, 3, 4],
              [5, 6, 7, 8],
              [9, 10, 11, 12],
              [13, 14, 15, 16]
            ]
          },
          "output": [
            [13, 9, 5, 1],
            [14, 10, 6, 2],
            [15, 11, 7, 3],
            [16, 12, 8, 4]
          ],
          "explanation": "Rotation of matrix with sequential numbers"
        }
      ],
      "constraints": {
        "n == matrix.length == matrix[i].length": true,
        "1 <= n <= 20": true,
        "-1000 <= matrix[i][j] <= 1000": true,
        "Must rotate in-place": true
      }
    },
    "74": {
      "title": "Spiral Matrix",
      "description": "Return all elements of an m x n matrix in spiral order",
      "cases": [
        {
          "id": 1,
          "input": {
            "matrix": [
              [1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]
            ]
          },
          "output": [1, 2, 3, 6, 9, 8, 7, 4, 5],
          "explanation": "Spiral order: rightâ†’downâ†’leftâ†’upâ†’right"
        },
        {
          "id": 2,
          "input": {
            "matrix": [
              [1, 2, 3, 4],
              [5, 6, 7, 8],
              [9, 10, 11, 12]
            ]
          },
          "output": [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7],
          "explanation": "Spiral order for non-square matrix"
        },
        {
          "id": 3,
          "input": {
            "matrix": [[1]]
          },
          "output": [1],
          "explanation": "Single element matrix"
        },
        {
          "id": 4,
          "input": {
            "matrix": [
              [1, 2],
              [3, 4]
            ]
          },
          "output": [1, 2, 4, 3],
          "explanation": "Spiral order for 2x2 matrix"
        },
        {
          "id": 5,
          "input": {
            "matrix": [
              [1, 2, 3],
              [4, 5, 6]
            ]
          },
          "output": [1, 2, 3, 6, 5, 4],
          "explanation": "Spiral order for 2x3 matrix"
        }
      ],
      "constraints": {
        "m == matrix.length": true,
        "n == matrix[i].length": true,
        "1 <= m, n <= 10": true,
        "-100 <= matrix[i][j] <= 100": true
      }
    },
    "75": {
      "title": "Set Matrix Zeroes",
      "description": "Given an m x n matrix, if an element is 0, set its entire row and column to 0",
      "cases": [
        {
          "id": 1,
          "input": {
            "matrix": [
              [1, 1, 1],
              [1, 0, 1],
              [1, 1, 1]
            ]
          },
          "output": [
            [1, 0, 1],
            [0, 0, 0],
            [1, 0, 1]
          ],
          "explanation": "Center element affects its row and column"
        },
        {
          "id": 2,
          "input": {
            "matrix": [
              [0, 1, 2, 0],
              [3, 4, 5, 2],
              [1, 3, 1, 5]
            ]
          },
          "output": [
            [0, 0, 0, 0],
            [0, 4, 5, 0],
            [0, 3, 1, 0]
          ],
          "explanation": "Multiple zeros affect their rows and columns"
        },
        {
          "id": 3,
          "input": {
            "matrix": [[1]]
          },
          "output": [[1]],
          "explanation": "Single non-zero element remains unchanged"
        },
        {
          "id": 4,
          "input": {
            "matrix": [
              [1, 0],
              [1, 1]
            ]
          },
          "output": [
            [0, 0],
            [1, 0]
          ],
          "explanation": "Zero in first row affects its row and column"
        },
        {
          "id": 5,
          "input": {
            "matrix": [
              [1, 2, 3],
              [4, 0, 6],
              [7, 8, 9],
              [10, 0, 12]
            ]
          },
          "output": [
            [1, 0, 3],
            [0, 0, 0],
            [7, 0, 9],
            [0, 0, 0]
          ],
          "explanation": "Two zeros in same column affect multiple rows"
        }
      ],
      "constraints": {
        "m == matrix.length": true,
        "n == matrix[i].length": true,
        "1 <= m, n <= 200": true,
        "-231 <= matrix[i][j] <= 231 - 1": true,
        "Must be done in-place": true
      }
    }
  }
}
